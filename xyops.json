{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"xyops": "1.0.0",
	"items": [
		{
			"type": "plugin",
			"data": {
				"id": "tbx1toolbox0001",
				"title": "Toolbox",
				"enabled": true,
				"type": "event",
				"command": "pwsh",
				"script": "#requires -Version 7.0\n# Copyright (c) 2026 Tim Alderweireldt. All rights reserved.\n<#!\nxyOps Toolbox Event Plugin (PowerShell 7)\nA collection of utility tools for xyOps including:\n- Token Generator\n- UUID Generator (v1, v4, v6, v7, nil, max)\n- Hash Text (MD5, SHA1, SHA256, SHA384, SHA512; others best-effort)\n- QR Code Generator (pure PowerShell with Reed-Solomon ECC)\n- Passphrase Generator (uses wordlist.txt if present, otherwise a small fallback list)\n- IBAN Validator\n- Lorem Ipsum Generator\n\nI/O contract:\n- Read one JSON object from STDIN (job), write progress/messages as JSON lines of the\n  form: { \"xy\": 1, ... } to STDOUT.\n- On success, emit: { \"xy\": 1, \"code\": 0, \"data\": <result>, \"description\": \"...\" }\n- On error, emit:   { \"xy\": 1, \"code\": <nonzero>, \"description\": \"...\" } and exit 1.\n\nTest locally:\n  pwsh -NoProfile -ExecutionPolicy Bypass -File .\\toolbox.ps1 < job.json\n#>\n\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n\nfunction Write-XY {\n  param([hashtable]$Object)\n  $payload = [ordered]@{ xy = 1 }\n  foreach ($k in $Object.Keys) { $payload[$k] = $Object[$k] }\n  [Console]::Out.WriteLine(($payload | ConvertTo-Json -Depth 20 -Compress))\n  [Console]::Out.Flush()\n}\n\nfunction Write-XYProgress {\n  param([double]$Value, [string]$Status)\n  $o = @{ progress = [math]::Round($Value, 4) }\n  if ($Status) { $o.status = $Status }\n  Write-XY $o\n}\n\nfunction Write-XYSuccess {\n  param($Data, [string]$Description)\n  $o = @{ code = 0; data = $Data }\n  if ($Description) { $o.description = $Description }\n  Write-XY $o\n}\n\nfunction Write-XYError {\n  param([int]$Code, [string]$Description)\n  Write-XY @{ code = $Code; description = $Description }\n}\n\nfunction Read-JobFromStdin {\n  $raw = [Console]::In.ReadToEnd()\n  if ([string]::IsNullOrWhiteSpace($raw)) { throw 'No job JSON received on STDIN' }\n  return $raw | ConvertFrom-Json -ErrorAction Stop\n}\n\nfunction ConvertTo-HexString {\n  param([byte[]]$Bytes)\n  ($Bytes | ForEach-Object { $_.ToString('x2') }) -join ''\n}\n\nfunction Get-RandomBytes {\n  param([int]$Length)\n  $data = New-Object byte[] ($Length)\n  [System.Security.Cryptography.RandomNumberGenerator]::Fill($data)\n  return $data\n}\n\nfunction Get-NestedValue {\n  param($Object, [string]$Path)\n  if (-not $Path -or ($Path.Trim() -eq '')) { return $Object }\n  $cur = $Object\n  foreach ($part in $Path.Split('.')) {\n    if ($null -eq $cur) { return $null }\n    if ($cur -is [System.Collections.IDictionary]) {\n      if (-not $cur.Contains($part)) { return $null }\n      $cur = $cur[$part]\n    }\n    else {\n      $cur = $cur.PSObject.Properties[$part].Value\n    }\n  }\n  return $cur\n}\n\n# Safe parameter getter - returns default if property doesn't exist\nfunction Get-Param {\n  param($Params, [string]$Name, $Default = $null)\n  if ($Params.PSObject.Properties.Name -contains $Name) { return $Params.$Name }\n  return $Default\n}\n\n# ------------------------- Token Generator -------------------------\nfunction Invoke-TokenGenerator {\n  param($Params)\n  Write-XYProgress 0.1 'Validating parameters...'\n\n  $length = [Math]::Min(1024, [Math]::Max(1, [int](Get-Param $Params 'tokenLength' 64)))\n  $count  = [Math]::Min(100,  [Math]::Max(1, [int](Get-Param $Params 'tokenCount' 1)))\n\n  $includeUpper = if ($Params.PSObject.Properties.Name -contains 'includeUppercase') { [bool]$Params.includeUppercase } else { $true }\n  $includeLower = if ($Params.PSObject.Properties.Name -contains 'includeLowercase') { [bool]$Params.includeLowercase } else { $true }\n  $includeNum   = if ($Params.PSObject.Properties.Name -contains 'includeNumbers')   { [bool]$Params.includeNumbers   } else { $true }\n  $includeSym   = if ($Params.PSObject.Properties.Name -contains 'includeSymbols')   { [bool]$Params.includeSymbols   } else { $false }\n\n  $chars = ''\n  if ($includeUpper) { $chars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' }\n  if ($includeLower) { $chars += 'abcdefghijklmnopqrstuvwxyz' }\n  if ($includeNum)   { $chars += '0123456789' }\n  if ($includeSym)   { $chars += '!@#$%^&*()_+-=[]{}|;:,.<>?' }\n  if ($chars.Length -eq 0) { throw 'At least one character set must be selected' }\n\n  Write-XYProgress 0.3 \"Generating $count token(s)...\"\n  $tokens = New-Object System.Collections.Generic.List[string]\n  for ($i = 0; $i -lt $count; $i++) {\n    $bytes = Get-RandomBytes -Length $length\n    $sb = New-Object System.Text.StringBuilder ($length)\n    for ($j = 0; $j -lt $length; $j++) {\n      [void]$sb.Append($chars[ $bytes[$j] % $chars.Length ])\n    }\n    $tokens.Add($sb.ToString())\n    if ($count -gt 1) { Write-XYProgress (0.3 + (0.6 * ($i + 1) / $count)) \"Generated $($i+1) of $count tokens...\" }\n  }\n\n  Write-XYProgress 0.95 'Finalizing...'\n  $charSets = @()\n  if ($includeUpper) { $charSets += 'uppercase' }\n  if ($includeLower) { $charSets += 'lowercase' }\n  if ($includeNum)   { $charSets += 'numbers' }\n  if ($includeSym)   { $charSets += 'symbols' }\n\n  # table for UI - use unary comma to prevent array flattening\n  $rows = @()\n  for ($i = 0; $i -lt $tokens.Count; $i++) {\n    $rows += ,@(($i + 1), $tokens[$i])\n  }\n  Write-XY @{ table = @{ title='Generated Tokens'; header=@('#','Token'); rows=$rows; caption = \"Generated $count token(s) with length $length using: $([string]::Join(', ', $charSets))\" } }\n\n  [pscustomobject]@{ tool = 'Token Generator'; tokens = $tokens; count = $count; length = $length; characterSets = $charSets }\n}\n\n# ------------------------- UUID Generators -------------------------\nfunction Format-UUIDComponents {\n  param([uint32]$timeLow, [uint16]$timeMid, [uint16]$timeHiAndVersion, [uint16]$clockSeq, [byte[]]$node)\n  $hex = {\n    param($n, $len)\n    (\"{0:X$len}\" -f $n).ToLower()\n  }\n  $nodeHex = ConvertTo-HexString -Bytes $node\n  return & $hex $timeLow 8 + '-' + (& $hex $timeMid 4) + '-' + (& $hex $timeHiAndVersion 4) + '-' + (& $hex $clockSeq 4) + '-' + $nodeHex\n}\n\nfunction ConvertTo-BigInteger { param([object]$n) return [System.Numerics.BigInteger]::Parse($n.ToString()) }\nfunction Get-PowerOfTwo { param([int]$bits) return [System.Numerics.BigInteger]::Pow([System.Numerics.BigInteger]::Parse('2'), $bits) }\n\nfunction New-UUIDv1 {\n  $nowMs = [DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds()\n  $greg  = ConvertTo-BigInteger 122192928000000000\n  $ts    = (ConvertTo-BigInteger $nowMs) * (ConvertTo-BigInteger 10000) + $greg  # 100-ns since 1582\n\n  $mod32 = Get-PowerOfTwo 32\n  $mod16 = Get-PowerOfTwo 16\n\n  $timeLow = [uint32]([System.Numerics.BigInteger]::Remainder($ts, $mod32))\n  $ts2 = [System.Numerics.BigInteger]::Divide($ts, $mod32)\n  $timeMid = [uint16]([System.Numerics.BigInteger]::Remainder($ts2, $mod16))\n  $ts3 = [System.Numerics.BigInteger]::Divide($ts2, $mod16)\n  $timeHiAndVersion = [uint16]([System.Numerics.BigInteger]::Remainder($ts3, (Get-PowerOfTwo 12)))\n  $timeHiAndVersion = ($timeHiAndVersion -band 0x0fff) -bor 0x1000\n\n  $clockSeq = ([int]([BitConverter]::ToUInt16((Get-RandomBytes 2),0)) -band 0x3fff) -bor 0x8000\n  $node = Get-RandomBytes 6\n  $node[0] = $node[0] -bor 0x01  # set multicast bit\n\n  return Format-UUIDComponents $timeLow $timeMid $timeHiAndVersion $clockSeq $node\n}\n\nfunction New-UUIDv4 {\n  $bytes = Get-RandomBytes 16\n  $bytes[6] = ($bytes[6] -band 0x0F) -bor 0x40  # version 4\n  $bytes[8] = ($bytes[8] -band 0x3F) -bor 0x80  # RFC 4122 variant\n  $hex = ConvertTo-HexString $bytes\n  return ($hex.Substring(0,8) + '-' + $hex.Substring(8,4) + '-' + $hex.Substring(12,4) + '-' + $hex.Substring(16,4) + '-' + $hex.Substring(20))\n}\n\nfunction New-UUIDv6 {\n  $nowMs = [DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds()\n  $greg  = ConvertTo-BigInteger 122192928000000000\n  $ts    = (ConvertTo-BigInteger $nowMs) * (ConvertTo-BigInteger 10000) + $greg\n\n  $shr28 = [System.Numerics.BigInteger]::Divide($ts, (Get-PowerOfTwo 28))\n  $timeHigh = [uint32]([System.Numerics.BigInteger]::Remainder($shr28, (Get-PowerOfTwo 32)))\n  $shr12 = [System.Numerics.BigInteger]::Divide($ts, (Get-PowerOfTwo 12))\n  $timeMid = [uint16]([System.Numerics.BigInteger]::Remainder($shr12, (Get-PowerOfTwo 16)))\n  $timeLowAndVersion = [uint16]([System.Numerics.BigInteger]::Remainder($ts, (Get-PowerOfTwo 12)))\n  $timeLowAndVersion = ($timeLowAndVersion -band 0x0fff) -bor 0x6000\n\n  $clockSeq = ([int]([BitConverter]::ToUInt16((Get-RandomBytes 2),0)) -band 0x3fff) -bor 0x8000\n  $node = Get-RandomBytes 6; $node[0] = $node[0] -bor 0x01\n\n  return Format-UUIDComponents $timeHigh $timeMid $timeLowAndVersion $clockSeq $node\n}\n\nfunction New-UUIDv7 {\n  $now = [DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds()\n  $bytes = New-Object byte[] 16\n  # first 6 bytes: big-endian ms timestamp\n  $bytes[0] = [byte] (($now -shr 40) -band 0xFF)\n  $bytes[1] = [byte] (($now -shr 32) -band 0xFF)\n  $bytes[2] = [byte] (($now -shr 24) -band 0xFF)\n  $bytes[3] = [byte] (($now -shr 16) -band 0xFF)\n  $bytes[4] = [byte] (($now -shr 8)  -band 0xFF)\n  $bytes[5] = [byte] ($now -band 0xFF)\n  # fill remaining with random\n  (Get-RandomBytes 10).CopyTo($bytes, 6)\n  # set version/variant\n  $bytes[6] = ($bytes[6] -band 0x0F) -bor 0x70\n  $bytes[8] = ($bytes[8] -band 0x3F) -bor 0x80\n  $hex = ConvertTo-HexString $bytes\n  return ($hex.Substring(0,8) + '-' + $hex.Substring(8,4) + '-' + $hex.Substring(12,4) + '-' + $hex.Substring(16,4) + '-' + $hex.Substring(20))\n}\n\nfunction Format-UUID {\n  param([string]$uuid, [string]$format)\n  switch ($format) {\n    'uppercase' { return $uuid.ToUpperInvariant() }\n    'nodashes'  { return $uuid.Replace('-', '') }\n    'urn'       { return \"urn:uuid:$uuid\" }\n    default     { return $uuid.ToLowerInvariant() }\n  }\n}\n\nfunction Invoke-UUIDGenerator {\n  param($Params)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $versionRaw = Get-Param $Params 'uuidVersion' 'v4'\n  $version = if ($null -eq $versionRaw) { 'v4' } else { $versionRaw.ToString() }\n  $formatRaw = Get-Param $Params 'uuidFormat' 'standard'\n  $format = if ($null -eq $formatRaw) { 'standard' } else { $formatRaw.ToString() }\n  $countRaw = Get-Param $Params 'uuidCount' 1\n  $count = [Math]::Min(100, [Math]::Max(1, [int]$(if ($null -eq $countRaw) { 1 } else { $countRaw })))\n\n  $map = @{ v1 = 'New-UUIDv1'; v4 = 'New-UUIDv4'; v6 = 'New-UUIDv6'; v7 = 'New-UUIDv7'; nil = 'nil'; max = 'max' }\n  if (-not $map.ContainsKey($version)) { throw \"Unknown UUID version: $version\" }\n\n  Write-XYProgress 0.3 \"Generating $count UUID(s) ($version)...\"\n  $uuids = New-Object System.Collections.Generic.List[string]\n  for ($i=0; $i -lt $count; $i++) {\n    switch ($version) {\n      'nil' { $u = '00000000-0000-0000-0000-000000000000' }\n      'max' { $u = 'ffffffff-ffff-ffff-ffff-ffffffffffff' }\n      default { $u = & (Get-Command $map[$version] -CommandType Function) }\n    }\n    $uuids.Add((Format-UUID $u $format))\n    if ($count -gt 1) { Write-XYProgress (0.3 + (0.6 * ($i + 1) / $count)) \"Generated $($i+1) of $count UUIDs...\" }\n  }\n\n  Write-XYProgress 0.95 'Finalizing...'\n  $versionNames = @{ v1='v1 (Time-based)'; v4='v4 (Random)'; v6='v6 (Reordered Time-based)'; v7='v7 (Unix Epoch Time-based)'; nil='Nil (All zeros)'; max='Max (All ones)' }\n  $formatNames  = @{ standard='Standard (lowercase)'; uppercase='Uppercase'; nodashes='No dashes'; urn='URN format' }\n\n  # Build rows with unary comma to prevent array flattening\n  $rows = @()\n  for ($i = 0; $i -lt $uuids.Count; $i++) {\n    $rows += ,@(($i + 1), $uuids[$i])\n  }\n  Write-XY @{ table = @{ title='Generated UUIDs'; header=@('#','UUID'); rows=$rows; caption = \"Generated $count $($versionNames[$version]) UUID(s) in $($formatNames[$format]) format\" } }\n\n  [pscustomobject]@{ tool='UUID Generator'; uuids=$uuids; count=$count; version=$version; versionName=$versionNames[$version]; format=$format; formatName=$formatNames[$format] }\n}\n\n# ------------------------- Hash Text -------------------------\nfunction Get-HashBytes {\n  param([string]$Text, [string]$Algorithm)\n  $bytes = [System.Text.Encoding]::UTF8.GetBytes($Text)\n  switch ($Algorithm) {\n    'md5'     { $algo = [System.Security.Cryptography.MD5]::Create() }\n    'sha1'    { $algo = [System.Security.Cryptography.SHA1]::Create() }\n    'sha256'  { $algo = [System.Security.Cryptography.SHA256]::Create() }\n    'sha384'  { $algo = [System.Security.Cryptography.SHA384]::Create() }\n    'sha512'  { $algo = [System.Security.Cryptography.SHA512]::Create() }\n    'ripemd160' { try { $algo = [System.Security.Cryptography.RIPEMD160]::Create() } catch { $algo = $null } }\n    'sha224'  { $algo = $null } # Not available in .NET without external libs\n    'sha3'    { $algo = $null } # Not available in .NET without external libs\n    default   { $algo = $null }\n  }\n  if ($null -eq $algo) { return $null }\n  try { return $algo.ComputeHash($bytes) } finally { $algo.Dispose() }\n}\n\nfunction ConvertTo-EncodedString {\n  param([byte[]]$Bytes, [string]$Encoding)\n  switch ($Encoding) {\n    'hex'    { return ConvertTo-HexString $Bytes }\n    'base64' { return [Convert]::ToBase64String($Bytes) }\n    'binary' { return [System.Text.Encoding]::ASCII.GetString($Bytes) }\n    default  { return ConvertTo-HexString $Bytes }\n  }\n}\n\n$HASH_ALGOS = @(\n  @{ id='md5'; name='MD5' },\n  @{ id='sha1'; name='SHA1' },\n  @{ id='sha256'; name='SHA256' },\n  @{ id='sha224'; name='SHA224' },\n  @{ id='sha512'; name='SHA512' },\n  @{ id='sha384'; name='SHA384' },\n  @{ id='sha3'; name='SHA3-256' },\n  @{ id='ripemd160'; name='RIPEMD160' }\n)\n\nfunction Invoke-HashText {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source   = Get-Param $Params 'hashSource' 'field'\n  $encoding = Get-Param $Params 'hashEncoding' 'hex'\n  $text = ''\n\n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $dataPath = Get-Param $Params 'hashDataPath' ''\n    $val = Get-NestedValue $inputData $dataPath\n    if ($null -eq $val) { throw \"Data path '$dataPath' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  }\n  else { $text = Get-Param $Params 'hashInput' '' }\n\n  Write-XYProgress 0.2 'Computing hashes...'\n  $hashes = @{}\n  $rows = @()\n  for ($i=0; $i -lt $HASH_ALGOS.Count; $i++) {\n    $algo = $HASH_ALGOS[$i]\n    $bytes = Get-HashBytes -Text $text -Algorithm $algo.id\n    if ($null -eq $bytes) { $digest = \"[Not supported]\" }\n    else { $digest = ConvertTo-EncodedString -Bytes $bytes -Encoding $encoding }\n    $hashes[$algo.id] = $digest\n    $rows += ,@($algo.name, $digest)\n    Write-XYProgress (0.2 + (0.7 * ($i+1) / $HASH_ALGOS.Count)) \"Computed $($algo.name)...\"\n  }\n\n  Write-XYProgress 0.95 'Finalizing...'\n  $encodingNames = @{ hex='Hexadecimal (base 16)'; base64='Base64'; binary='Binary (raw)' }\n  Write-XY @{ table = @{ title='Hash Results'; header=@('Algorithm','Hash'); rows=$rows; caption=\"Hashed $($text.Length) character(s) using $($encodingNames[$encoding]) encoding\" } }\n\n  [pscustomobject]@{ tool='Hash Text'; inputLength=$text.Length; encoding=$encoding; encodingName=$encodingNames[$encoding]; hashes = $hashes }\n}\n\n# ------------------------- QR Code Generator (Pure PowerShell) -------------------------\n# Complete QR Code implementation with Reed-Solomon ECC - supports byte mode, version 1-4\n# No external dependencies required\n\n# Galois Field GF(2^8) operations for Reed-Solomon\n$script:GF_EXP = New-Object int[] 512\n$script:GF_LOG = New-Object int[] 256\n$script:GF_INIT = $false\n\nfunction Initialize-GaloisField {\n  if ($script:GF_INIT) { return }\n  [int]$x = 1\n  for ([int]$i = 0; $i -lt 255; $i++) {\n    $script:GF_EXP[$i] = $x\n    $script:GF_LOG[$x] = $i\n    $x = $x -shl 1\n    if ($x -band 0x100) { $x = $x -bxor 0x11D }\n  }\n  for ([int]$i = 255; $i -lt 512; $i++) {\n    [int]$idx = $i - 255\n    $script:GF_EXP[$i] = $script:GF_EXP[$idx]\n  }\n  $script:GF_INIT = $true\n}\n\nfunction Get-GFMultiply([int]$a, [int]$b) {\n  if ($a -eq 0 -or $b -eq 0) { return 0 }\n  return $script:GF_EXP[$script:GF_LOG[$a] + $script:GF_LOG[$b]]\n}\n\nfunction Get-RSGenerator([int]$nsym) {\n  Initialize-GaloisField\n  # Generator polynomial g(x) = (x + α^0)(x + α^1)...(x + α^(nsym-1))\n  # Stored with coefficients from highest to lowest degree\n  [int[]]$g = New-Object int[] ($nsym + 1)\n  $g[0] = 1\n  for ([int]$i = 0; $i -lt $nsym; $i++) {\n    # Multiply by (x + α^i)\n    for ([int]$j = $i + 1; $j -gt 0; $j--) {\n      [int]$jm1 = $j - 1\n      if ($g[$jm1] -ne 0) {\n        $g[$j] = $g[$j] -bxor (Get-GFMultiply $g[$jm1] $script:GF_EXP[$i])\n      }\n    }\n  }\n  return $g\n}\n\nfunction Get-RSEncode([int[]]$data, [int]$nsym) {\n  Initialize-GaloisField\n  [int[]]$gen = Get-RSGenerator $nsym\n  [int[]]$feedback = New-Object int[] $nsym\n  \n  for ([int]$i = 0; $i -lt $data.Length; $i++) {\n    [int]$coef = $data[$i] -bxor $feedback[0]\n    # Shift feedback register\n    for ([int]$j = 0; $j -lt ($nsym - 1); $j++) {\n      [int]$jp1 = $j + 1\n      $feedback[$j] = $feedback[$jp1]\n    }\n    $feedback[$nsym - 1] = 0\n    # Add generator polynomial contribution\n    if ($coef -ne 0) {\n      for ([int]$j = 0; $j -lt $nsym; $j++) {\n        [int]$gidx = $j + 1\n        $feedback[$j] = $feedback[$j] -bxor (Get-GFMultiply $coef $gen[$gidx])\n      }\n    }\n  }\n  return $feedback\n}\n\n# QR Code parameters for all ECC levels (L, M, Q, H)\n# ECC codewords per version and level\n$script:QR_ECCBYTES = @{\n  1 = @{ L=7;  M=10; Q=13; H=17 }\n  2 = @{ L=10; M=16; Q=22; H=28 }\n  3 = @{ L=15; M=26; Q=36; H=44 }\n  4 = @{ L=20; M=18; Q=26; H=16 }\n}\n# Data codewords capacity per version and level\n$script:QR_DATACAP = @{\n  1 = @{ L=19; M=16; Q=13; H=9  }\n  2 = @{ L=34; M=28; Q=22; H=16 }\n  3 = @{ L=55; M=44; Q=34; H=26 }\n  4 = @{ L=80; M=64; Q=48; H=36 }\n}\n# Max text bytes in byte mode (data capacity - 2 bytes overhead for mode+length)\n$script:QR_TEXTCAP = @{\n  1 = @{ L=17; M=14; Q=11; H=7  }\n  2 = @{ L=32; M=26; Q=20; H=14 }\n  3 = @{ L=53; M=42; Q=32; H=24 }\n  4 = @{ L=78; M=62; Q=46; H=34 }\n}\n\n# Format info strings for each ECC level and mask (pre-computed with BCH and XOR mask)\n$script:QR_FORMAT_INFO = @{\n  L = @('111011111000100','111001011110011','111110110101010','111100010011101','110011000101111','110001100011000','110110001000001','110100101110110')\n  M = @('101010000010010','101000100100101','101111001111100','101101101001011','100010111111001','100000011001110','100111110010111','100101010100000')\n  Q = @('011010101011111','011000001101000','011111100110001','011101000000110','010010010110100','010000110000011','010111011011010','010101111101101')\n  H = @('001011010001001','001001110111110','001110011100111','001100111010000','000011101100010','000001001010101','000110100001100','000100000111011')\n}\n\nfunction Get-QRVersion([int]$Length, [string]$ECC = 'M') {\n  foreach ($v in 1..4) {\n    if ($Length -le $script:QR_TEXTCAP[$v][$ECC]) { return $v }\n  }\n  throw \"Text too long for QR code with ECC $ECC (max $($script:QR_TEXTCAP[4][$ECC]) bytes)\"\n}\n\nfunction ConvertTo-QRDataBytes([string]$Text, [int]$Version, [string]$ECC = 'M') {\n  [byte[]]$textBytes = [System.Text.Encoding]::UTF8.GetBytes($Text)\n  [int]$dataCap = $script:QR_DATACAP[$Version][$ECC]\n  [int]$textLen = $textBytes.Length\n  \n  # Build bit stream\n  $bits = New-Object System.Collections.Generic.List[int]\n  \n  # Mode indicator: 0100 (byte mode)\n  $bits.Add(0); $bits.Add(1); $bits.Add(0); $bits.Add(0)\n  \n  # Character count (8 bits for versions 1-9)\n  for ([int]$i = 7; $i -ge 0; $i--) { $bits.Add(($textLen -shr $i) -band 1) }\n  \n  # Data bytes (8 bits each)\n  for ([int]$i = 0; $i -lt $textLen; $i++) {\n    [int]$b = $textBytes[$i]\n    for ([int]$j = 7; $j -ge 0; $j--) { $bits.Add(($b -shr $j) -band 1) }\n  }\n  \n  # Terminator (up to 4 zeros)\n  [int]$totalDataBits = $dataCap * 8\n  [int]$termLen = [Math]::Min(4, $totalDataBits - $bits.Count)\n  for ([int]$i = 0; $i -lt $termLen; $i++) { $bits.Add(0) }\n  \n  # Pad to byte boundary\n  while (($bits.Count % 8) -ne 0) { $bits.Add(0) }\n  \n  # Convert bits to bytes\n  $result = New-Object System.Collections.Generic.List[int]\n  for ([int]$i = 0; $i -lt $bits.Count; $i += 8) {\n    [int]$b = 0\n    for ([int]$j = 0; $j -lt 8; $j++) { $b = ($b -shl 1) -bor $bits[$i + $j] }\n    $result.Add($b)\n  }\n  \n  # Pad bytes (alternating 236, 17)\n  [int]$padIdx = 0\n  while ($result.Count -lt $dataCap) {\n    $result.Add($(if (($padIdx % 2) -eq 0) { 236 } else { 17 }))\n    $padIdx++\n  }\n  \n  return $result.ToArray()\n}\n\nfunction New-QRMatrix([int]$Version) {\n  [int]$size = 17 + $Version * 4\n  $matrix = New-Object 'int[,]' $size, $size\n  $fixed = New-Object 'bool[,]' $size, $size\n  for ($i = 0; $i -lt $size; $i++) { for ($j = 0; $j -lt $size; $j++) { $matrix[$i,$j] = 0 } }\n  return @{ m = $matrix; f = $fixed; size = $size }\n}\n\nfunction Set-QRModule($M, [int]$r, [int]$c, [int]$val, [bool]$fix = $true) {\n  [int]$sz = $M.size\n  if ($r -ge 0 -and $r -lt $sz -and $c -ge 0 -and $c -lt $sz) {\n    $M.m[$r,$c] = $val\n    $M.f[$r,$c] = $fix\n  }\n}\n\nfunction Set-QRFinderPattern($M, [int]$row, [int]$col) {\n  for ($r = -1; $r -le 7; $r++) {\n    for ($c = -1; $c -le 7; $c++) {\n      $inOuter = ($r -eq 0 -or $r -eq 6 -or $c -eq 0 -or $c -eq 6)\n      $inInner = ($r -ge 2 -and $r -le 4 -and $c -ge 2 -and $c -le 4)\n      $val = if ($r -eq -1 -or $r -eq 7 -or $c -eq -1 -or $c -eq 7) { 0 } elseif ($inOuter -or $inInner) { 1 } else { 0 }\n      Set-QRModule $M ($row + $r) ($col + $c) $val\n    }\n  }\n}\n\nfunction Set-QRTimingPatterns($M) {\n  [int]$sz = $M.size\n  for ($i = 8; $i -lt ($sz - 8); $i++) {\n    $val = if ($i % 2 -eq 0) { 1 } else { 0 }\n    Set-QRModule $M 6 $i $val\n    Set-QRModule $M $i 6 $val\n  }\n}\n\n# Alignment pattern positions for versions 2-4\n$script:QR_ALIGN_POS = @{\n  2 = @(6, 18)\n  3 = @(6, 22)\n  4 = @(6, 26)\n}\n\nfunction Set-QRAlignmentPattern($M, [int]$row, [int]$col) {\n  # 5x5 pattern with center at (row, col)\n  for ([int]$r = -2; $r -le 2; $r++) {\n    for ([int]$c = -2; $c -le 2; $c++) {\n      [int]$val = if ([Math]::Abs($r) -eq 2 -or [Math]::Abs($c) -eq 2 -or ($r -eq 0 -and $c -eq 0)) { 1 } else { 0 }\n      Set-QRModule $M ($row + $r) ($col + $c) $val\n    }\n  }\n}\n\nfunction Set-QRAlignmentPatterns($M, [int]$Version) {\n  if ($Version -lt 2) { return }\n  $positions = $script:QR_ALIGN_POS[$Version]\n  if (-not $positions) { return }\n  \n  # For versions 2-6, there's only one alignment pattern (not overlapping with finders)\n  # It's at the intersection of the last two positions, but not where finders are\n  foreach ($row in $positions) {\n    foreach ($col in $positions) {\n      # Skip if this would overlap with a finder pattern (top-left, top-right, bottom-left)\n      [int]$sz = $M.size\n      $skipTopLeft = ($row -lt 9 -and $col -lt 9)\n      $skipTopRight = ($row -lt 9 -and $col -gt ($sz - 9))\n      $skipBottomLeft = ($row -gt ($sz - 9) -and $col -lt 9)\n      if (-not ($skipTopLeft -or $skipTopRight -or $skipBottomLeft)) {\n        Set-QRAlignmentPattern $M $row $col\n      }\n    }\n  }\n}\n\nfunction Set-QRFormatInfo($M, [int]$mask, [string]$ECC = 'M') {\n  [int]$sz = $M.size\n  # Get format info for this ECC level and mask\n  $fmtStr = $script:QR_FORMAT_INFO[$ECC][$mask]\n  [int[]]$bits = @()\n  for ([int]$i = 0; $i -lt 15; $i++) { $bits += [int]($fmtStr[$i].ToString()) }\n  \n  # Format info locations around top-left finder (bits 0-14)\n  # Horizontal strip at row 8: columns 0,1,2,3,4,5, (skip 6), 7,8\n  Set-QRModule $M 8 0 $bits[0]\n  Set-QRModule $M 8 1 $bits[1]\n  Set-QRModule $M 8 2 $bits[2]\n  Set-QRModule $M 8 3 $bits[3]\n  Set-QRModule $M 8 4 $bits[4]\n  Set-QRModule $M 8 5 $bits[5]\n  Set-QRModule $M 8 7 $bits[6]\n  Set-QRModule $M 8 8 $bits[7]\n  \n  # Vertical strip at col 8: rows 0,1,2,3,4,5, (skip 6), 7,8\n  Set-QRModule $M 0 8 $bits[14]\n  Set-QRModule $M 1 8 $bits[13]\n  Set-QRModule $M 2 8 $bits[12]\n  Set-QRModule $M 3 8 $bits[11]\n  Set-QRModule $M 4 8 $bits[10]\n  Set-QRModule $M 5 8 $bits[9]\n  Set-QRModule $M 7 8 $bits[8]\n  \n  # Second copy - horizontal at row 8, right side\n  [int]$rightStart = $sz - 8\n  Set-QRModule $M 8 ($rightStart + 0) $bits[7]\n  Set-QRModule $M 8 ($rightStart + 1) $bits[8]\n  Set-QRModule $M 8 ($rightStart + 2) $bits[9]\n  Set-QRModule $M 8 ($rightStart + 3) $bits[10]\n  Set-QRModule $M 8 ($rightStart + 4) $bits[11]\n  Set-QRModule $M 8 ($rightStart + 5) $bits[12]\n  Set-QRModule $M 8 ($rightStart + 6) $bits[13]\n  Set-QRModule $M 8 ($rightStart + 7) $bits[14]\n  \n  # Second copy - vertical at col 8, bottom\n  [int]$bottomStart = $sz - 7\n  Set-QRModule $M ($bottomStart + 0) 8 $bits[6]\n  Set-QRModule $M ($bottomStart + 1) 8 $bits[5]\n  Set-QRModule $M ($bottomStart + 2) 8 $bits[4]\n  Set-QRModule $M ($bottomStart + 3) 8 $bits[3]\n  Set-QRModule $M ($bottomStart + 4) 8 $bits[2]\n  Set-QRModule $M ($bottomStart + 5) 8 $bits[1]\n  Set-QRModule $M ($bottomStart + 6) 8 $bits[0]\n  \n  # Dark module is always at (4*version + 9, 8) = (size-8, 8) and always dark\n  Set-QRModule $M ($sz - 8) 8 1\n}\n\nfunction Write-QRData($M, [int[]]$data, [int]$mask) {\n  [int]$size = $M.size\n  [int]$bitIdx = 0\n  [int]$totalBits = $data.Count * 8\n  [bool]$upward = $true\n  \n  for ([int]$col = $size - 1; $col -ge 1; $col -= 2) {\n    if ($col -eq 6) { $col = 5 }\n    $rowRange = if ($upward) { ($size - 1)..0 } else { 0..($size - 1) }\n    foreach ($row in $rowRange) {\n      for ([int]$c = 0; $c -lt 2; $c++) {\n        [int]$cc = $col - $c\n        if (-not $M.f[$row, $cc]) {\n          [int]$bit = 0\n          if ($bitIdx -lt $totalBits) {\n            [int]$byteIdx = [Math]::Floor($bitIdx / 8)\n            [int]$bitPos = 7 - ($bitIdx % 8)\n            $bit = ($data[$byteIdx] -shr $bitPos) -band 1\n          }\n          # Apply mask\n          [bool]$masked = switch ($mask) {\n            0 { (($row + $cc) % 2) -eq 0 }\n            1 { ($row % 2) -eq 0 }\n            2 { ($cc % 3) -eq 0 }\n            3 { (($row + $cc) % 3) -eq 0 }\n            4 { (([Math]::Floor($row / 2) + [Math]::Floor($cc / 3)) % 2) -eq 0 }\n            5 { ((($row * $cc) % 2) + (($row * $cc) % 3)) -eq 0 }\n            6 { (((($row * $cc) % 2) + (($row * $cc) % 3)) % 2) -eq 0 }\n            7 { (((($row + $cc) % 2) + (($row * $cc) % 3)) % 2) -eq 0 }\n          }\n          if ($masked) { $bit = 1 - $bit }\n          $M.m[$row, $cc] = $bit\n          $bitIdx++\n        }\n      }\n    }\n    $upward = -not $upward\n  }\n}\n\nfunction Get-QRPenalty($M) {\n  [int]$penalty = 0\n  [int]$size = $M.size\n  # Rule 1: consecutive modules in row/column\n  for ([int]$i = 0; $i -lt $size; $i++) {\n    [int]$rowCount = 1; [int]$colCount = 1\n    for ([int]$j = 1; $j -lt $size; $j++) {\n      [int]$jm1 = $j - 1\n      if ($M.m[$i,$j] -eq $M.m[$i,$jm1]) { $rowCount++ } else { if ($rowCount -ge 5) { $penalty += $rowCount - 2 }; $rowCount = 1 }\n      if ($M.m[$j,$i] -eq $M.m[$jm1,$i]) { $colCount++ } else { if ($colCount -ge 5) { $penalty += $colCount - 2 }; $colCount = 1 }\n    }\n    if ($rowCount -ge 5) { $penalty += $rowCount - 2 }\n    if ($colCount -ge 5) { $penalty += $colCount - 2 }\n  }\n  # Rule 4: proportion of dark modules\n  [int]$dark = 0\n  for ([int]$i = 0; $i -lt $size; $i++) { for ([int]$j = 0; $j -lt $size; $j++) { if ($M.m[$i,$j] -eq 1) { $dark++ } } }\n  [int]$percent = [Math]::Floor(($dark * 100) / ($size * $size))\n  $penalty += [Math]::Abs($percent - 50) * 2\n  return $penalty\n}\n\nfunction New-QRCode([string]$Text, [string]$ECC = 'M') {\n  [int]$version = Get-QRVersion $Text.Length $ECC\n  [int[]]$dataBytes = ConvertTo-QRDataBytes $Text $version $ECC\n  [int]$eccCount = $script:QR_ECCBYTES[$version][$ECC]\n  [int[]]$eccBytes = Get-RSEncode $dataBytes $eccCount\n  # Combine data and ECC bytes\n  [int[]]$allBytes = New-Object int[] ($dataBytes.Length + $eccBytes.Length)\n  for ([int]$i = 0; $i -lt $dataBytes.Length; $i++) { $allBytes[$i] = $dataBytes[$i] }\n  for ([int]$i = 0; $i -lt $eccBytes.Length; $i++) { $allBytes[$dataBytes.Length + $i] = $eccBytes[$i] }\n  \n  # Try all masks and pick best\n  [int]$bestMask = 0\n  [int]$bestPenalty = [int]::MaxValue\n  $bestMatrix = $null\n  \n  for ([int]$mask = 0; $mask -lt 8; $mask++) {\n    $M = New-QRMatrix $version\n    [int]$sz = $M.size\n    Set-QRFinderPattern $M 0 0\n    Set-QRFinderPattern $M 0 ($sz - 7)\n    Set-QRFinderPattern $M ($sz - 7) 0\n    Set-QRTimingPatterns $M\n    Set-QRAlignmentPatterns $M $version\n    Set-QRFormatInfo $M $mask $ECC\n    Write-QRData $M $allBytes $mask\n    $penalty = Get-QRPenalty $M\n    if ($penalty -lt $bestPenalty) {\n      $bestPenalty = $penalty\n      $bestMask = $mask\n      $bestMatrix = $M\n    }\n  }\n  return $bestMatrix\n}\n\n# CRC32 lookup table (initialized once at script load)\n$Global:PNG_CRC32_TABLE = $null\n\nfunction Get-PngCrc32 {\n  param([byte[]]$Data)\n  # Initialize CRC32 lookup table if needed\n  if ($null -eq $Global:PNG_CRC32_TABLE) {\n    $Global:PNG_CRC32_TABLE = New-Object long[] 256\n    for ($n = 0; $n -lt 256; $n++) {\n      [long]$c = $n\n      for ($k = 0; $k -lt 8; $k++) {\n        if (($c -band 1) -eq 1) { $c = 0xEDB88320L -bxor ($c -shr 1) }\n        else { $c = $c -shr 1 }\n      }\n      $Global:PNG_CRC32_TABLE[$n] = $c\n    }\n  }\n  [long]$crc = 0xFFFFFFFFL\n  foreach ($b in $Data) {\n    $idx = [int](($crc -bxor $b) -band 0xFF)\n    $crc = $Global:PNG_CRC32_TABLE[$idx] -bxor ($crc -shr 8)\n  }\n  return [long](($crc -bxor 0xFFFFFFFFL) -band 0xFFFFFFFFL)\n}\n\nfunction ConvertTo-HexColor([string]$hex) {\n  # Parse #RRGGBB or RRGGBB to RGB bytes\n  $hex = $hex.TrimStart('#')\n  if ($hex.Length -eq 6) {\n    [byte]$r = [Convert]::ToByte($hex.Substring(0,2), 16)\n    [byte]$g = [Convert]::ToByte($hex.Substring(2,2), 16)\n    [byte]$b = [Convert]::ToByte($hex.Substring(4,2), 16)\n    return @($r, $g, $b)\n  }\n  return @([byte]0, [byte]0, [byte]0)\n}\n\nfunction ConvertTo-PngBytes {\n  param($M, [int]$Scale, [string]$Foreground = '#000000', [string]$Background = '#ffffff')\n  [int]$qrSize = $M.size\n  [int]$margin = 4\n  [int]$imgSize = ($qrSize + $margin * 2) * $Scale\n  \n  # Parse colors\n  $fgColor = ConvertTo-HexColor $Foreground\n  $bgColor = ConvertTo-HexColor $Background\n  \n  $png = New-Object System.Collections.Generic.List[byte]\n  \n  # PNG Signature\n  @(0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A) | ForEach-Object { $png.Add([byte]$_) }\n  \n  # Helper to write chunk\n  $writeChunk = {\n    param([string]$Type, [byte[]]$Data)\n    $len = if ($Data) { $Data.Length } else { 0 }\n    $png.Add([byte](($len -shr 24) -band 0xFF))\n    $png.Add([byte](($len -shr 16) -band 0xFF))\n    $png.Add([byte](($len -shr 8) -band 0xFF))\n    $png.Add([byte]($len -band 0xFF))\n    $typeBytes = [System.Text.Encoding]::ASCII.GetBytes($Type)\n    $typeBytes | ForEach-Object { $png.Add($_) }\n    if ($Data -and $Data.Length -gt 0) { $Data | ForEach-Object { $png.Add($_) } }\n    $crcData = New-Object System.Collections.Generic.List[byte]\n    $typeBytes | ForEach-Object { $crcData.Add($_) }\n    if ($Data) { $Data | ForEach-Object { $crcData.Add($_) } }\n    $crc = Get-PngCrc32 -Data $crcData.ToArray()\n    $png.Add([byte](($crc -shr 24) -band 0xFF))\n    $png.Add([byte](($crc -shr 16) -band 0xFF))\n    $png.Add([byte](($crc -shr 8) -band 0xFF))\n    $png.Add([byte]($crc -band 0xFF))\n  }\n  \n  # IHDR chunk - 8-bit RGB\n  $ihdr = New-Object System.Collections.Generic.List[byte]\n  $ihdr.Add([byte](($imgSize -shr 24) -band 0xFF))\n  $ihdr.Add([byte](($imgSize -shr 16) -band 0xFF))\n  $ihdr.Add([byte](($imgSize -shr 8) -band 0xFF))\n  $ihdr.Add([byte]($imgSize -band 0xFF))\n  $ihdr.Add([byte](($imgSize -shr 24) -band 0xFF))\n  $ihdr.Add([byte](($imgSize -shr 16) -band 0xFF))\n  $ihdr.Add([byte](($imgSize -shr 8) -band 0xFF))\n  $ihdr.Add([byte]($imgSize -band 0xFF))\n  $ihdr.Add([byte]8)   # Bit depth: 8\n  $ihdr.Add([byte]2)   # Color type: 2 = RGB\n  $ihdr.Add([byte]0)   # Compression\n  $ihdr.Add([byte]0)   # Filter\n  $ihdr.Add([byte]0)   # Interlace\n  & $writeChunk 'IHDR' $ihdr.ToArray()\n  \n  # Build raw image data (RGB)\n  $rawData = New-Object System.Collections.Generic.List[byte]\n  for ([int]$y = 0; $y -lt $imgSize; $y++) {\n    $rawData.Add([byte]0)  # Filter type: None\n    for ([int]$x = 0; $x -lt $imgSize; $x++) {\n      [int]$qx = [Math]::Floor($x / $Scale) - $margin\n      [int]$qy = [Math]::Floor($y / $Scale) - $margin\n      $color = $bgColor  # Background by default (margin)\n      if ($qx -ge 0 -and $qx -lt $qrSize -and $qy -ge 0 -and $qy -lt $qrSize) {\n        $color = if ($M.m[$qy, $qx] -eq 1) { $fgColor } else { $bgColor }\n      }\n      $rawData.Add($color[0])  # R\n      $rawData.Add($color[1])  # G\n      $rawData.Add($color[2])  # B\n    }\n  }\n  \n  # Compress with DeflateStream\n  $ms = New-Object System.IO.MemoryStream\n  $ds = New-Object System.IO.Compression.DeflateStream($ms, [System.IO.Compression.CompressionLevel]::Optimal)\n  $ds.Write($rawData.ToArray(), 0, $rawData.Count)\n  $ds.Close()\n  $compressed = $ms.ToArray()\n  $ms.Close()\n  \n  # IDAT chunk (zlib wrapper)\n  $idat = New-Object System.Collections.Generic.List[byte]\n  $idat.Add([byte]0x78); $idat.Add([byte]0x9C)\n  $compressed | ForEach-Object { $idat.Add($_) }\n  # Adler32 checksum\n  [long]$a = 1; [long]$b = 0\n  $rawBytes = $rawData.ToArray()\n  for ($i = 0; $i -lt $rawBytes.Length; $i++) {\n    $a = ($a + [long]$rawBytes[$i]) % 65521\n    $b = ($b + $a) % 65521\n  }\n  [long]$adler = ($b -shl 16) -bor $a\n  $idat.Add([byte](($adler -shr 24) -band 0xFF))\n  $idat.Add([byte](($adler -shr 16) -band 0xFF))\n  $idat.Add([byte](($adler -shr 8) -band 0xFF))\n  $idat.Add([byte]($adler -band 0xFF))\n  & $writeChunk 'IDAT' $idat.ToArray()\n  \n  # IEND chunk\n  & $writeChunk 'IEND' $null\n  \n  return $png.ToArray()\n}\n\nfunction Invoke-QRCode {\n  param($Params, $JobInput, [string]$Cwd)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.qrSource ?? 'field')\n  $text = ''\n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $dataPath = ($Params.qrDataPath ?? '')\n    $val = Get-NestedValue $inputData $dataPath\n    if ($null -eq $val) { throw \"Data path '$dataPath' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.qrText ?? '') }\n  if (-not $text) { throw 'No text or URL provided for QR code' }\n\n  $size = [Math]::Min(1024, [Math]::Max(64, [int]($Params.qrSize ?? 256)))\n  $filename = ($Params.qrFilename ?? 'qrcode.png')\n  if (-not $filename.EndsWith('.png')) { $filename = [System.IO.Path]::ChangeExtension($filename, '.png') }\n  $filePath = Join-Path $Cwd $filename\n  \n  # Get colors (default black on white)\n  $foreground = ($Params.qrForeground ?? '#000000')\n  $background = ($Params.qrBackground ?? '#ffffff')\n  \n  # Get error correction level (L, M, Q, H)\n  $errorLevel = ($Params.qrErrorLevel ?? 'M').ToUpper()\n  if ($errorLevel -notin @('L','M','Q','H')) { $errorLevel = 'M' }\n  $errorNames = @{ L='Low (~7%)'; M='Medium (~15%)'; Q='Quartile (~25%)'; H='High (~30%)' }\n\n  Write-XYProgress 0.3 \"Generating QR code with ECC level $errorLevel...\"\n  $M = New-QRCode $text $errorLevel\n  [int]$qrSize = $M.size\n  [int]$version = ($qrSize - 17) / 4\n\n  Write-XYProgress 0.7 'Generating PNG image...'\n  $scale = [Math]::Max(1, [int]($size / ($qrSize + 8)))\n  $pngBytes = ConvertTo-PngBytes -M $M -Scale $scale -Foreground $foreground -Background $background\n  [System.IO.File]::WriteAllBytes($filePath, $pngBytes)\n\n  $fi = Get-Item -LiteralPath $filePath\n  Write-XYProgress 0.95 'Finalizing...'\n\n  $displayContent = if ($text.Length -gt 50) { $text.Substring(0,50) + '...' } else { $text }\n  $actualSize = ($qrSize + 8) * $scale\n\n  $result = [pscustomobject]@{ tool='QR Code Generator'; text=$text; textLength=$text.Length; filename=$filename; fileSize=$fi.Length; size=$actualSize; version=$version; errorLevel=$errorLevel; errorLevelName=$errorNames[$errorLevel]; foreground=$foreground; background=$background }\n\n  Write-XY @{ files = @($filename) }\n  Write-XY @{ table = @{ title='QR Code Generated'; header=@('Property','Value'); rows=@(@('Content', $displayContent), @('QR Version', \"$version ($qrSize x $qrSize modules)\"), @('Image Size',\"${actualSize}x${actualSize} pixels\"), @('Error Correction',$errorNames[$errorLevel]), @('Colors',\"$foreground on $background\"), @('File',$filename), @('File Size',\"$($fi.Length) bytes\")); caption = \"QR code saved as $filename (pure PowerShell with Reed-Solomon ECC)\" } }\n\n  $result\n}\n\n# ------------------------- Passphrase Generator -------------------------\n$PP_SYMBOLS = '!@#$%^&*'\n\nfunction Get-WordList {\n  # Comprehensive English wordlist with words from 3 to 8 characters\n  return @(\n    # 3-letter words\n    'ace','act','add','age','ago','aid','aim','air','all','and','ant','any','ape','apt','arc','are','ark','arm','art','ask','ate','bad','bag','bar','bat','bay','bed','bee','bet','big','bin','bit','box','boy','bud','bug','bun','bus','but','buy','cab','can','cap','car','cat','caw','cob','cod','cog','cop','cot','cow','cry','cub','cud','cue','cup','cut','dad','dam','day','den','dew','did','die','dig','dim','din','dip','dog','don','dot','dry','dub','dud','due','dug','dye','ear','eat','egg','ego','elf','elk','elm','end','era','eve','eye','fan','far','fat','fax','fed','fee','few','fib','fig','fin','fir','fit','fix','fly','foe','fog','for','fox','fry','fun','fur','gag','gap','gas','gel','gem','get','gig','gin','git','god','got','gum','gun','gut','guy','gym','had','has','hat','hay','hem','hen','her','hew','hex','hid','him','hip','his','hit','hog','hop','hot','how','hub','hue','hug','hum','hut','ice','ill','ink','inn','ion','its','ivy','jab','jag','jam','jar','jaw','jay','jet','jig','job','jog','jot','joy','jug','keg','ken','key','kid','kin','kit','lab','lad','lag','lap','law','lax','lay','lea','leg','let','lid','lie','lip','lit','log','lot','low','mad','man','map','mat','maw','max','may','men','met','mid','mix','mob','mod','mom','mop','mud','mug','nab','nag','nap','net','new','nil','nip','nit','nod','nor','not','now','nun','nut','oak','oar','oat','odd','off','oft','oil','old','one','opt','orb','ore','our','out','owe','owl','own','pad','pal','pan','pap','par','pat','paw','pax','pay','pea','peg','pen','pep','per','pet','pew','pie','pig','pin','pip','pit','ply','pod','pop','pot','pox','pro','pry','pub','pug','pun','pup','pus','put','rag','ram','ran','rap','rat','raw','ray','red','rep','rib','rid','rig','rim','rip','rob','rod','roe','rot','row','rub','rug','rum','run','rut','rye','sac','sad','sag','sap','sat','saw','sax','say','sea','see','set','sew','sex','she','shy','sin','sip','sir','sis','sit','six','ska','sky','sly','sob','sod','son','sop','sot','sow','sox','soy','spa','spy','sty','sub','sum','sun','sup','tab','tad','tag','tan','tap','tar','tax','tea','ten','the','thy','tic','tie','tin','tip','toe','ton','too','top','tot','tow','toy','try','tub','tug','two','urn','use','van','vet','vex','via','vie','vow','wad','wag','wan','war','was','wax','way','web','wed','wee','wet','who','why','wig','win','wit','woe','wok','won','woo','wow','yak','yam','yap','yaw','yea','yen','yes','yet','yew','yin','you','yow','yup','zap','zed','zee','zen','zoo','zoo',\n\n    # 4-letter words\n    'able','acid','aged','also','area','army','away','baby','back','ball','band','bank','base','bath','beat','been','beer','bell','belt','best','bill','bird','bite','blow','blue','boat','body','bomb','bond','bone','book','boot','bore','born','boss','both','bowl','boxy','boys','brag','brat','bred','brew','brim','bulb','bulk','bull','bump','burn','burst','buye','cafe','cage','cake','call','calm','came','camp','cane','cape','card','care','cart','case','cash','cast','cave','cell','cent','chap','chat','chef','chew','chin','chip','chop','cite','city','clad','clam','clap','class','claw','clay','clip','club','clue','coal','coat','code','coil','coin','cold','colo','comb','come','cook','cool','cope','copy','cord','core','cork','cost','cozy','crab','cram','crew','crop','crow','cube','cult','curb','cure','curl','cute','dang','dare','dark','dart','dash','data','date','dawn','days','dead','deaf','deal','dean','dear','debt','deck','deer','demo','dent','desk','dial','dice','died','diet','dime','dine','dire','dirt','disc','dish','disk','dive','dock','doll','dome','done','door','dope','dose','down','doze','drag','draw','drew','drip','drop','drub','drug','drum','dual','duck','dude','duel','dues','dull','dumb','dump','dune','dunk','dupe','dusk','dust','duty','each','earl','earn','earth','ease','east','easy','echo','edge','edit','eggs','egos','else','emit','envy','even','ever','evil','exam','exit','face','fact','fade','fail','fair','fake','fall','fame','fang','fare','farm','fast','fate','fawn','fear','feat','feed','feel','feet','fell','felt','fern','fest','feud','fiat','fief','file','fill','film','find','fine','fire','firm','fish','fist','five','flag','flak','flap','flat','flaw','flax','flay','flea','fled','flee','flew','flex','flip','flit','flog','flop','flow','flue','flux','foal','foam','foci','foil','fold','folk','fond','font','food','fool','foot','ford','fore','fork','form','fort','foul','four','fowl','foxy','frat','fray','free','fresh','frie','frog','from','fuel','full','fume','fund','funk','fury','fuse','fuss','fuzz','gait','gala','game','gang','garb','gash','gate','gave','gawk','gaze','gear','geek','gene','germ','gift','girl','give','glad','glee','glen','glow','glue','glum','glut','gnaw','goal','goat','goes','gold','golf','gone','gong','good','goof','gore','gory','gown','grab','gram','gray','grew','grey','grid','grin','grip','grit','grow','grub','guam','guar','guess','guest','guide','guild','guilt','guise','gulf','gull','gulp','guru','gush',\n\n    # 5-letter words\n    'about','above','abuse','actor','acute','admit','adopt','adult','after','again','agent','agree','ahead','alarm','album','alert','alike','alive','allow','alone','along','alter','among','anger','angle','angry','apart','apple','apply','arena','argue','arise','array','aside','asset','audio','audit','avoid','award','aware','badly','baker','bases','basic','basis','beach','began','begin','begun','being','below','bench','billy','birth','black','blame','blind','block','blood','board','boost','booth','bound','brain','brand','bread','break','breed','brief','bring','broad','broke','brown','build','built','buyer','cable','calif','carry','catch','cause','chain','chair','chart','chase','cheap','check','chest','chief','child','china','choir','choose','chronic','church','cigar','claim','class','clean','clear','click','clock','close','coach','coast','could','count','court','cover','craft','crash','cream','crime','cross','crowd','crown','curve','cycle','daily','dance','dated','dealt','death','debut','delay','depth','doing','doubt','dozen','draft','drama','drawn','dream','dress','drill','drink',\n\n    # 6-letter words\n    'accept','access','accuse','achieve','acquire','across','acting','action','active','actual','advice','advise','affect','afford','aftermath','against','agency','agenda','almost','already','although','always','amazing','amount','analyst','ancient','another','anxiety','anybody','anything','anytime','apparent','approach','approval','argument','artistic','assembly','athletic','attitude','attorney','audience','authority','available','average','backward','bacteria','baseball','beautiful','because','becoming','bedroom','behavior','believe','benefit','besides','between','billion','birthday','boundary','brother','building','business','calendar','campaign','capacity','capital','captain','capture','careful','carrying','category','caution','celebrate','cellular','cemetery','certainly',\n\n    # 7-letter words\n    'ability','absence','academy','account','accuracy','achieve','acquire','address','advance','adverse','advisory','advocate','aircraft','alcohol','although','amazing','analyst','ancient','another','anxiety','anybody','anything','anytime','apparent','approach','approval','argument','artistic','assembly','athletic','attitude','attorney','audience','authority','available','average','backward','bacteria','baseball','beautiful','because','becoming','bedroom','behavior','believe','benefit','besides','between','billion','birthday','boundary','brother','building','business','calendar','campaign','capacity','capital','captain','capture','careful','carrying','category','caution','celebrate','cellular','cemetery','certainly',\n\n    # 8-letter words\n    'absolute','academic','accepted','accident','according','accounting','accuracy','achievement','acknowledge','acquire','acquisition','activity','actually','additional','adequate','adjustment','administration','advantage','adventure','advertising','advisable','advisory','advocate','aesthetic','affecting','affection','affiliate','affirmative','affordable','afternoon','afterward','against','aggressive','agreement','agricultural','alcoholic','algorithm','alliance','although','altogether','amazing','ambassador','amendment','ammunition','amongst','amounted','analysis','ancestor','ancient','anderson','announce','annual','another','answering','antibody','anybody','anything','anywhere','apparent','apparently','appealing','appearance','appetite','application','appointment','appreciate','approach','appropriate','approval','approximately','architect','argument','arise','arrangement','arrival','artistic','assembly','athletic','attaching','attempt','attend','attention','attitude','attorney','attract','auction','audience','author','authority','available','average','avoid','awaiting','background','bacteria','baseball','beautiful','because','becoming','bedroom','behavior','believe','benefit'\n\n  )\n}\n\nfunction New-Passphrase {\n  param(\n    [int]$WordCount,\n    [int]$MaxWordLength,\n    [ValidateSet('hyphen','space','dot','underscore','none')] [string]$Separator,\n    [bool]$Capitalize,\n    [bool]$IncludeNumber,\n    [bool]$IncludeSymbol\n  )\n  $words = Get-WordList | Where-Object { $_.Length -ge 3 -and $_.Length -le $MaxWordLength }\n  if ($words.Count -lt 100) { throw \"Not enough words with max length $MaxWordLength. Provide a larger wordlist.txt or increase max length.\" }\n\n  $sel = New-Object System.Collections.Generic.List[string]\n  for ($i=0; $i -lt $WordCount; $i++) {\n    $w = $words[ [System.Security.Cryptography.RandomNumberGenerator]::GetInt32($words.Count) ]\n    if ($Capitalize) { $w = $w.Substring(0,1).ToUpper() + $w.Substring(1) }\n    $sel.Add($w)\n  }\n\n  $sepMap = @{ hyphen='-'; space=' '; dot='.'; underscore = '_'; none='' }\n  $sep = $sepMap[$Separator]\n  $pass = ($sel -join $sep)\n\n  if ($IncludeNumber) {\n    $num = [System.Security.Cryptography.RandomNumberGenerator]::GetInt32(100).ToString()\n    $parts = [System.Collections.Generic.List[string]]::new()\n    if ($sep) { $parts.AddRange([string[]]$pass.Split($sep)) } else { $parts.AddRange([string[]]$sel) }\n    $pos = [System.Security.Cryptography.RandomNumberGenerator]::GetInt32($parts.Count + 1)\n    $parts.Insert($pos, $num)\n    $pass = $parts -join $sep\n  }\n  if ($IncludeSymbol) {\n    $sym = $PP_SYMBOLS[[System.Security.Cryptography.RandomNumberGenerator]::GetInt32($PP_SYMBOLS.Length)]\n    $pos = [System.Security.Cryptography.RandomNumberGenerator]::GetInt32($pass.Length + 1)\n    $pass = $pass.Insert($pos, [string]$sym)\n  }\n  return $pass\n}\n\nfunction Measure-Entropy {\n  param([int]$WordCount,[int]$Pool,[bool]$IncludeNumber,[bool]$IncludeSymbol)\n  $e = $WordCount * [Math]::Log($Pool, 2)\n  if ($IncludeNumber) { $e += [Math]::Log(100,2) + [Math]::Log($WordCount + 1,2) }\n  if ($IncludeSymbol) { $e += [Math]::Log($PP_SYMBOLS.Length,2) + [Math]::Log(50,2) }\n  [Math]::Round($e)\n}\n\nfunction Get-StrengthRating {\n  param([int]$Entropy)\n  if ($Entropy -lt 40) { return @{ rating='Weak'; symbol='[!]' } }\n  if ($Entropy -lt 60) { return @{ rating='Fair'; symbol='[~]' } }\n  if ($Entropy -lt 80) { return @{ rating='Strong'; symbol='[+]' } }\n  if ($Entropy -lt 100){ return @{ rating='Very Strong'; symbol='[++]' } }\n  return @{ rating='Excellent'; symbol='[*]' }\n}\n\nfunction Invoke-PassphraseGenerator {\n  param($Params)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $wordCount = [Math]::Min(10, [Math]::Max(3, [int]($Params.ppWordCount ?? 4)))\n  $maxLen    = [Math]::Min(15, [Math]::Max(3, [int]($Params.ppMaxWordLength ?? 8)))\n  $sep       = ($Params.ppSeparator ?? 'hyphen')\n  $cap       = if ($Params.PSObject.Properties.Name -contains 'ppCapitalize')   { [bool]$Params.ppCapitalize }   else { $true }\n  $incNum    = if ($Params.PSObject.Properties.Name -contains 'ppIncludeNumber'){ [bool]$Params.ppIncludeNumber } else { $true }\n  $incSym    = if ($Params.PSObject.Properties.Name -contains 'ppIncludeSymbol'){ [bool]$Params.ppIncludeSymbol } else { $false }\n  $count     = [Math]::Min(20, [Math]::Max(1, [int]($Params.ppCount ?? 1)))\n\n  $pool = (Get-WordList | Where-Object { $_.Length -ge 3 -and $_.Length -le $maxLen }).Count\n  if ($pool -lt 100) { throw \"Not enough words with max length $maxLen. Provide wordlist.txt or increase max length.\" }\n\n  Write-XYProgress 0.3 \"Generating $count passphrase(s)...\"\n  $options = @{ WordCount=$wordCount; MaxWordLength=$maxLen; Separator=$sep; Capitalize=$cap; IncludeNumber=$incNum; IncludeSymbol=$incSym }\n  $list = for ($i=0; $i -lt $count; $i++) {\n    Write-XYProgress (0.3 + (0.6 * ($i+1) / $count)) \"Generated $($i+1) of $count...\"\n    New-Passphrase @options\n  }\n\n  Write-XYProgress 0.95 'Finalizing...'\n  $entropy = Measure-Entropy -WordCount $wordCount -Pool $pool -IncludeNumber:$incNum -IncludeSymbol:$incSym\n  $strength = Get-StrengthRating $entropy\n\n  $rows = @(); $i=0; foreach ($pp in $list) { $i++; $rows += ,@($i,$pp,$pp.Length) }\n  Write-XY @{ table = @{ title='Generated Passphrases'; header=@('#','Passphrase','Length'); rows=$rows; caption = \"$($strength.symbol) $($strength.rating) | $wordCount words | ~$entropy bits entropy | Word pool: $pool\" } }\n\n  [pscustomobject]@{ tool='Passphrase Generator'; passphrases=$list; count=$count; wordCount=$wordCount; maxWordLength=$maxLen; separator=$sep; capitalize=$cap; includeNumber=$incNum; includeSymbol=$incSym; wordPoolSize=$pool; entropy=$entropy; strength=$strength.rating }\n}\n\n# ------------------------- IBAN Validator -------------------------\n$IBAN_LENGTHS = [ordered]@{\n  AL=28; AD=24; AT=20; AZ=28; BH=22; BY=28; BE=16; BA=20; BR=29;\n  BG=22; CR=22; HR=21; CY=28; CZ=24; DK=18; DO=28; TL=23; EE=20;\n  EG=29; SV=28; FO=18; FI=18; FR=27; GE=22; DE=22; GI=23; GR=27;\n  GL=18; GT=28; HU=28; IS=26; IQ=23; IE=22; IL=23; IT=27; JO=30;\n  KZ=20; XK=20; KW=30; LV=21; LB=28; LY=25; LI=21; LT=20; LU=20;\n  MK=19; MT=31; MR=27; MU=30; MC=27; MD=24; ME=22; NL=18; NO=15;\n  PK=24; PS=29; PL=28; PT=25; QA=29; RO=24; LC=32; SM=27; ST=25;\n  SA=24; RS=22; SC=31; SK=24; SI=19; ES=24; SD=18; SE=24; CH=21;\n  TN=24; TR=26; UA=29; AE=23; GB=22; VA=22; VG=24\n}\n$COUNTRY_NAMES = @{ AL='Albania'; AD='Andorra'; AT='Austria'; AZ='Azerbaijan'; BH='Bahrain'; BY='Belarus'; BE='Belgium'; BA='Bosnia and Herzegovina'; BR='Brazil'; BG='Bulgaria'; CR='Costa Rica'; HR='Croatia'; CY='Cyprus'; CZ='Czech Republic'; DK='Denmark'; DO='Dominican Republic'; TL='East Timor'; EE='Estonia'; EG='Egypt'; SV='El Salvador'; FO='Faroe Islands'; FI='Finland'; FR='France'; GE='Georgia'; DE='Germany'; GI='Gibraltar'; GR='Greece'; GL='Greenland'; GT='Guatemala'; HU='Hungary'; IS='Iceland'; IQ='Iraq'; IE='Ireland'; IL='Israel'; IT='Italy'; JO='Jordan'; KZ='Kazakhstan'; XK='Kosovo'; KW='Kuwait'; LV='Latvia'; LB='Lebanon'; LY='Libya'; LI='Liechtenstein'; LT='Lithuania'; LU='Luxembourg'; MK='North Macedonia'; MT='Malta'; MR='Mauritania'; MU='Mauritius'; MC='Monaco'; MD='Moldova'; ME='Montenegro'; NL='Netherlands'; NO='Norway'; PK='Pakistan'; PS='Palestine'; PL='Poland'; PT='Portugal'; QA='Qatar'; RO='Romania'; LC='Saint Lucia'; SM='San Marino'; ST='Sao Tome and Principe'; SA='Saudi Arabia'; RS='Serbia'; SC='Seychelles'; SK='Slovakia'; SI='Slovenia'; ES='Spain'; SD='Sudan'; SE='Sweden'; CH='Switzerland'; TN='Tunisia'; TR='Turkey'; UA='Ukraine'; AE='United Arab Emirates'; GB='United Kingdom'; VA='Vatican City'; VG='British Virgin Islands' }\n\nfunction Test-IBAN {\n  param([string]$Iban)\n  $clean = ($Iban -replace '\\s','').ToUpperInvariant()\n  if (-not ($clean -match '^[A-Z]{2}[0-9]{2}[A-Z0-9]+$')) { return @{ valid=$false; error='Invalid IBAN format. Must start with 2 letters, 2 digits, then alphanumeric characters.' } }\n  $cc = $clean.Substring(0,2); $check = $clean.Substring(2,2); $bban = $clean.Substring(4)\n  if (-not $IBAN_LENGTHS.Contains($cc)) { return @{ valid=$false; error=\"Unknown country code: $cc\" } }\n  $expected = $IBAN_LENGTHS[$cc]\n  if ($clean.Length -ne $expected) { return @{ valid=$false; error=\"Invalid length for $cc. Expected $expected characters, got $($clean.Length).\" } }\n  $rearr = $clean.Substring(4) + $clean.Substring(0,4)\n  $num = ($rearr.ToCharArray() | ForEach-Object { if ($_ -match '[0-9]') { [string]$_ } else { ([int][byte][char]$_ - 55).ToString() } }) -join ''\n  # MOD-97 with big integer division\n  $remainder = 0\n  foreach ($d in $num.ToCharArray()) { $remainder = (($remainder * 10) + [int]$d) % 97 }\n  if ($remainder -ne 1) { return @{ valid=$false; error='Invalid check digits. The IBAN checksum verification failed.' } }\n  $formatted = ($clean -split '(.{4})' | Where-Object { $_ -ne '' }) -join ' '\n  return @{ valid=$true; iban=$clean; formatted=$formatted; countryCode=$cc; countryName=($COUNTRY_NAMES[$cc] ?? $cc); checkDigits=$check; bban=$bban; length=$clean.Length }\n}\n\nfunction Invoke-IBANValidator {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.ibanSource ?? 'field')\n  $iban = ''\n  if ($source -eq 'input') {\n    $inputData = $JobInput.data; if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.ibanDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $iban = [string]$val\n  } else { $iban = [string]($Params.ibanInput ?? '') }\n  if (-not $iban) { throw 'No IBAN provided' }\n  Write-XYProgress 0.5 'Validating IBAN...'\n  $validation = Test-IBAN $iban\n  Write-XYProgress 0.95 'Finalizing...'\n  $table = if ($validation.valid) {\n    @{ title='IBAN Validation Result'; header=@('Property','Value'); rows=@(@('Status','[OK] Valid IBAN'), @('Formatted',$validation.formatted), @('Country',\"$($validation.countryName) ($($validation.countryCode))\"), @('Check Digits',$validation.checkDigits), @('BBAN',$validation.bban), @('Length',\"$($validation.length) characters\")); caption='IBAN is valid and passes MOD-97 checksum verification' }\n  } else {\n    @{ title='IBAN Validation Result'; header=@('Property','Value'); rows=@(@('Status','[X] Invalid IBAN'), @('Input',$iban), @('Error',$validation.error)); caption='IBAN validation failed' }\n  }\n  Write-XY @{ table = $table }\n  $result = @{ tool='IBAN Validator'; input=$iban }\n  $result += $validation\n  [pscustomobject]$result\n}\n\n# ------------------------- Lorem Ipsum -------------------------\n$LOREM = @('lorem','ipsum','dolor','sit','amet','consectetur','adipiscing','elit','sed','do','eiusmod','tempor','incididunt','ut','labore','et','dolore','magna','aliqua','enim','ad','minim','veniam','quis','nostrud','exercitation','ullamco','laboris','nisi','aliquip','ex','ea','commodo','consequat','duis','aute','irure','in','reprehenderit','voluptate','velit','esse','cillum','fugiat','nulla','pariatur','excepteur','sint','occaecat','cupidatat','non','proident','sunt','culpa','qui','officia','deserunt','mollit','anim','id','est','laborum','ac','accumsan','aliquet','aliquam','ante','aptent','arcu','at','auctor','augue','bibendum','blandit','condimentum','congue','cras','curabitur','cursus','dapibus','diam','dictum','dictumst','dignissim','dis','donec','egestas','eget','eleifend','elementum','eros','etiam','eu','euismod','facilisi','facilisis','fames','faucibus','felis','fermentum','feugiat','fringilla','fusce','gravida','habitant','habitasse','hac','hendrerit','himenaeos','iaculis','imperdiet','inceptos','integer','interdum','justo','lacinia','lacus','laoreet','lectus','leo','libero','ligula','litora','lobortis','luctus','maecenas','massa','mattis','mauris','metus','mi','morbi','nam','nascetur','natoque','nec','neque','nibh','nisl','nullam','nunc','odio','orci','ornare','parturient','pellentesque','penatibus','per','pharetra','phasellus','placerat','platea','porta','porttitor','posuere','potenti','praesent','pretium','primis','proin','pulvinar','purus','quam','quisque','rhoncus','ridiculus','risus','rutrum','sagittis','sapien','scelerisque','semper','senectus','sociosqu','sodales','sollicitudin','suscipit','suspendisse','taciti','tellus','tempus','tincidunt','torquent','tortor','tristique','turpis','ultrices','ultricies','urna','varius','vehicula','vel','venenatis','vestibulum','vitae','vivamus','viverra','volutpat','vulputate')\n\nfunction New-LoremSentence {\n  param([int]$WordsPerSentence,[bool]$StartWithLorem,[bool]$IsFirstSentence)\n  $count = [Math]::Max(3, [Math]::Min(50, $WordsPerSentence))\n  $arr = New-Object System.Collections.Generic.List[string]\n  for ($i=0; $i -lt $count; $i++) {\n    if ($StartWithLorem -and $IsFirstSentence -and $i -lt 2) {\n      $word = if ($i -eq 0) { 'Lorem' } else { 'ipsum' }\n      $arr.Add($word)\n    } else {\n      $w = $LOREM[ [System.Security.Cryptography.RandomNumberGenerator]::GetInt32($LOREM.Count) ]\n      if ($i -eq 0) { $w = $w.Substring(0,1).ToUpper() + $w.Substring(1) }\n      $arr.Add($w)\n    }\n  }\n  return ($arr -join ' ') + '.'\n}\n\nfunction New-LoremParagraph {\n  param([int]$SentencesPerParagraph,[int]$WordsPerSentence,[bool]$StartWithLorem,[bool]$IsFirstParagraph)\n  $sc = [Math]::Max(1, [Math]::Min(20, $SentencesPerParagraph))\n  $sentences = for ($i=0; $i -lt $sc; $i++) { New-LoremSentence -WordsPerSentence $WordsPerSentence -StartWithLorem $StartWithLorem -IsFirstSentence:($IsFirstParagraph -and $i -eq 0) }\n  return ($sentences -join ' ')\n}\n\nfunction Invoke-LoremIpsum {\n  param($Params, [string]$Cwd)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $paragraphs = [Math]::Min(50, [Math]::Max(1, [int]($Params.loremParagraphs ?? 3)))\n  $spp        = [Math]::Min(20, [Math]::Max(1, [int]($Params.loremSentences ?? 4)))\n  $wps        = [Math]::Min(50, [Math]::Max(3, [int]($Params.loremWords ?? 10)))\n  $start      = if ($Params.PSObject.Properties.Name -contains 'loremStartWithLorem') { [bool]$Params.loremStartWithLorem } else { $true }\n  $asHtml     = if ($Params.PSObject.Properties.Name -contains 'loremAsHtml') { [bool]$Params.loremAsHtml } else { $false }\n\n  Write-XYProgress 0.3 \"Generating $paragraphs paragraph(s)...\"\n  $pars = for ($i=0; $i -lt $paragraphs; $i++) { Write-XYProgress (0.3 + (0.6 * ($i+1) / $paragraphs)) \"Generated $($i+1) of $paragraphs paragraphs...\"; New-LoremParagraph -SentencesPerParagraph $spp -WordsPerSentence $wps -StartWithLorem $start -IsFirstParagraph:($i -eq 0) }\n\n  Write-XYProgress 0.9 'Saving files...'\n  $text = if ($asHtml) { ($pars | ForEach-Object { \"<p>$_</p>\" }) -join [Environment]::NewLine } else { ($pars -join ([Environment]::NewLine + [Environment]::NewLine)) }\n  $totalWords = ($pars | ForEach-Object { ($_ -split '\\s+').Length } | Measure-Object -Sum).Sum\n  $totalSentences = ($pars | ForEach-Object { ($_ -split '\\.').Count - 1 } | Measure-Object -Sum).Sum\n\n  # Save as .txt file\n  $txtFilename = 'lorem-ipsum.txt'\n  $txtPath = Join-Path $Cwd $txtFilename\n  [System.IO.File]::WriteAllText($txtPath, $text, [System.Text.Encoding]::UTF8)\n\n  # Save as .md file (with header)\n  $mdFilename = 'lorem-ipsum.md'\n  $mdPath = Join-Path $Cwd $mdFilename\n  $mdContent = \"# Lorem Ipsum`n`n$text\"\n  [System.IO.File]::WriteAllText($mdPath, $mdContent, [System.Text.Encoding]::UTF8)\n\n  Write-XYProgress 0.95 'Finalizing...'\n\n  # Output files for xyOps download\n  Write-XY @{ files = @($txtFilename, $mdFilename) }\n\n  Write-XY @{ text = @{ title='Generated Lorem Ipsum'; content=$text; caption = \"$paragraphs paragraph(s) | $totalSentences sentences | $totalWords words | $($text.Length) characters$(if ($asHtml) { ' (HTML)' } else { '' })\" } }\n  [pscustomobject]@{ tool='Lorem Ipsum Generator'; text=$text; paragraphs=$paragraphs; sentencesPerParagraph=$spp; wordsPerSentence=$wps; startWithLorem=$start; asHtml=$asHtml; totalWords=$totalWords; totalSentences=$totalSentences; totalCharacters=$text.Length; files=@($txtFilename, $mdFilename) }\n}\n\n# ------------------------- Base64 Encoder/Decoder -------------------------\nfunction Invoke-Base64 {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $mode = ($Params.base64Mode ?? 'encode')\n  $source = ($Params.base64Source ?? 'field')\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.base64DataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.base64Input ?? '') }\n  \n  if (-not $text) { throw 'No input text provided' }\n  \n  Write-XYProgress 0.5 \"$(if ($mode -eq 'encode') { 'Encoding' } else { 'Decoding' }) text...\"\n  \n  $output = ''\n  $success = $true\n  $errorMsg = ''\n  \n  try {\n    if ($mode -eq 'encode') {\n      $bytes = [System.Text.Encoding]::UTF8.GetBytes($text)\n      $output = [Convert]::ToBase64String($bytes)\n    } else {\n      $bytes = [Convert]::FromBase64String($text)\n      $output = [System.Text.Encoding]::UTF8.GetString($bytes)\n    }\n  } catch {\n    $success = $false\n    $errorMsg = $_.Exception.Message\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  if ($success) {\n    Write-XY @{ table = @{ title=\"Base64 $(if ($mode -eq 'encode') { 'Encoded' } else { 'Decoded' })\"; header=@('Property','Value'); rows=@(@('Mode', $(if ($mode -eq 'encode') { 'Encode' } else { 'Decode' })), @('Input Length', \"$($text.Length) characters\"), @('Output Length', \"$($output.Length) characters\"), @('Output', $(if ($output.Length -gt 100) { $output.Substring(0,100) + '...' } else { $output }))); caption=\"Successfully $(if ($mode -eq 'encode') { 'encoded' } else { 'decoded' }) text\" } }\n    [pscustomobject]@{ tool='Base64 Encoder/Decoder'; mode=$mode; input=$text; output=$output; inputLength=$text.Length; outputLength=$output.Length; success=$true }\n  } else {\n    Write-XY @{ table = @{ title='Base64 Error'; header=@('Property','Value'); rows=@(@('Mode', $(if ($mode -eq 'encode') { 'Encode' } else { 'Decode' })), @('Error', $errorMsg)); caption='Operation failed' } }\n    [pscustomobject]@{ tool='Base64 Encoder/Decoder'; mode=$mode; input=$text; success=$false; error=$errorMsg }\n  }\n}\n\n# ------------------------- URL Encoder/Decoder -------------------------\nfunction Invoke-UrlEncode {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $mode = ($Params.urlMode ?? 'encode')\n  $source = ($Params.urlSource ?? 'field')\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.urlDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.urlInput ?? '') }\n  \n  if (-not $text) { throw 'No input text provided' }\n  \n  Write-XYProgress 0.5 \"$(if ($mode -eq 'encode') { 'Encoding' } else { 'Decoding' }) URL...\"\n  \n  $output = if ($mode -eq 'encode') {\n    [System.Uri]::EscapeDataString($text)\n  } else {\n    [System.Uri]::UnescapeDataString($text)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ table = @{ title=\"URL $(if ($mode -eq 'encode') { 'Encoded' } else { 'Decoded' })\"; header=@('Property','Value'); rows=@(@('Mode', $(if ($mode -eq 'encode') { 'Encode' } else { 'Decode' })), @('Input', $(if ($text.Length -gt 80) { $text.Substring(0,80) + '...' } else { $text })), @('Output', $(if ($output.Length -gt 80) { $output.Substring(0,80) + '...' } else { $output }))); caption=\"Successfully $(if ($mode -eq 'encode') { 'encoded' } else { 'decoded' }) URL\" } }\n  [pscustomobject]@{ tool='URL Encoder/Decoder'; mode=$mode; input=$text; output=$output; inputLength=$text.Length; outputLength=$output.Length }\n}\n\n# ------------------------- Timestamp Converter -------------------------\nfunction Invoke-TimestampConverter {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $mode = ($Params.tsMode ?? 'now')\n  $source = ($Params.tsSource ?? 'field')\n  $inputValue = ''\n  \n  if ($mode -ne 'now') {\n    if ($source -eq 'input') {\n      $inputData = $JobInput.data\n      if (-not $inputData) { throw 'No input data available from previous job' }\n      $path = ($Params.tsDataPath ?? '')\n      $val = Get-NestedValue $inputData $path\n      if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n      $inputValue = [string]$val\n    } else { $inputValue = ($Params.tsInput ?? '') }\n  }\n  \n  Write-XYProgress 0.5 'Converting timestamp...'\n  \n  $dt = $null\n  $parseError = ''\n  \n  switch ($mode) {\n    'now' { $dt = [DateTimeOffset]::UtcNow }\n    'unix' {\n      try {\n        $unixSeconds = [long]$inputValue\n        $dt = [DateTimeOffset]::FromUnixTimeSeconds($unixSeconds)\n      } catch { $parseError = \"Invalid Unix timestamp: $inputValue\" }\n    }\n    'unixms' {\n      try {\n        $unixMs = [long]$inputValue\n        $dt = [DateTimeOffset]::FromUnixTimeMilliseconds($unixMs)\n      } catch { $parseError = \"Invalid Unix milliseconds timestamp: $inputValue\" }\n    }\n    'iso' {\n      try {\n        $dt = [DateTimeOffset]::Parse($inputValue)\n      } catch { $parseError = \"Invalid ISO 8601 date: $inputValue\" }\n    }\n    default { $parseError = \"Unknown mode: $mode\" }\n  }\n  \n  if ($parseError) { throw $parseError }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $unixSec = $dt.ToUnixTimeSeconds()\n  $unixMs = $dt.ToUnixTimeMilliseconds()\n  $iso = $dt.ToString('yyyy-MM-ddTHH:mm:ss.fffzzz')\n  $isoUtc = $dt.UtcDateTime.ToString('yyyy-MM-ddTHH:mm:ss.fffZ')\n  $human = $dt.ToString('dddd, MMMM d, yyyy h:mm:ss tt')\n  $humanUtc = $dt.UtcDateTime.ToString('dddd, MMMM d, yyyy h:mm:ss tt') + ' UTC'\n  \n  $rows = @(\n    @('Unix Timestamp (seconds)', $unixSec.ToString()),\n    @('Unix Timestamp (milliseconds)', $unixMs.ToString()),\n    @('ISO 8601', $iso),\n    @('ISO 8601 (UTC)', $isoUtc),\n    @('Human Readable', $human),\n    @('Human Readable (UTC)', $humanUtc)\n  )\n  \n  Write-XY @{ table = @{ title='Timestamp Conversion'; header=@('Format','Value'); rows=$rows; caption=\"Converted from $(if ($mode -eq 'now') { 'current time' } else { $mode })\" } }\n  [pscustomobject]@{ tool='Timestamp Converter'; mode=$mode; input=$(if ($mode -eq 'now') { 'now' } else { $inputValue }); unixSeconds=$unixSec; unixMilliseconds=$unixMs; iso8601=$iso; iso8601Utc=$isoUtc; humanReadable=$human; humanReadableUtc=$humanUtc }\n}\n\n# ------------------------- JSON Formatter -------------------------\nfunction Invoke-JsonFormatter {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $mode = ($Params.jsonMode ?? 'prettify')\n  $source = ($Params.jsonSource ?? 'field')\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.jsonDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.jsonInput ?? '') }\n  \n  if (-not $text) { throw 'No JSON input provided' }\n  \n  Write-XYProgress 0.5 'Processing JSON...'\n  \n  $parsed = $null\n  $output = ''\n  $valid = $true\n  $errorMsg = ''\n  \n  try {\n    $parsed = $text | ConvertFrom-Json -ErrorAction Stop\n    $output = switch ($mode) {\n      'prettify' { $parsed | ConvertTo-Json -Depth 20 }\n      'minify'   { $parsed | ConvertTo-Json -Depth 20 -Compress }\n      'validate' { $parsed | ConvertTo-Json -Depth 20 }\n    }\n  } catch {\n    $valid = $false\n    $errorMsg = $_.Exception.Message\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $modeNames = @{ prettify='Prettify'; minify='Minify'; validate='Validate' }\n  \n  if ($valid) {\n    # Show full output for small results, truncate at 10KB for very large outputs\n    $preview = if ($output.Length -gt 10000) { $output.Substring(0,10000) + \"`n... [truncated, full output in data]\" } else { $output }\n    Write-XY @{ table = @{ title='JSON Result'; header=@('Property','Value'); rows=@(@('Mode', $modeNames[$mode]), @('Valid', '[OK] Yes'), @('Input Size', \"$($text.Length) chars\"), @('Output Size', \"$($output.Length) chars\")); caption='JSON is valid' } }\n    Write-XY @{ text = @{ title='Output'; content=$preview; caption='' } }\n    [pscustomobject]@{ tool='JSON Formatter'; mode=$mode; valid=$true; input=$text; output=$output; inputLength=$text.Length; outputLength=$output.Length }\n  } else {\n    Write-XY @{ table = @{ title='JSON Result'; header=@('Property','Value'); rows=@(@('Mode', $modeNames[$mode]), @('Valid', '[X] No'), @('Error', $errorMsg)); caption='JSON is invalid' } }\n    [pscustomobject]@{ tool='JSON Formatter'; mode=$mode; valid=$false; error=$errorMsg }\n  }\n}\n\n# ------------------------- String Case Converter -------------------------\nfunction Invoke-CaseConverter {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $targetCase = ($Params.caseType ?? 'lower')\n  $source = ($Params.caseSource ?? 'field')\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.caseDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.caseInput ?? '') }\n  \n  if (-not $text) { throw 'No input text provided' }\n  \n  Write-XYProgress 0.5 'Converting case...'\n  \n  $output = switch ($targetCase) {\n    'lower'     { $text.ToLowerInvariant() }\n    'upper'     { $text.ToUpperInvariant() }\n    'title'     { (Get-Culture).TextInfo.ToTitleCase($text.ToLower()) }\n    'sentence'  { if ($text.Length -gt 0) { $text.Substring(0,1).ToUpper() + $text.Substring(1).ToLower() } else { '' } }\n    'camel'     { $words = $text -split '[\\s_-]+'; $first = $true; ($words | ForEach-Object { if ($first) { $first = $false; $_.ToLower() } else { (Get-Culture).TextInfo.ToTitleCase($_.ToLower()) } }) -join '' }\n    'pascal'    { $words = $text -split '[\\s_-]+'; ($words | ForEach-Object { (Get-Culture).TextInfo.ToTitleCase($_.ToLower()) }) -join '' }\n    'snake'     { ($text -creplace '([A-Z])', '_$1' -replace '[\\s-]+', '_').ToLower().Trim('_') -replace '__+', '_' }\n    'kebab'     { ($text -creplace '([A-Z])', '-$1' -replace '[\\s_]+', '-').ToLower().Trim('-') -replace '--+', '-' }\n    'constant'  { ($text -creplace '([A-Z])', '_$1' -replace '[\\s-]+', '_').ToUpper().Trim('_') -replace '__+', '_' }\n    default     { $text }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $caseNames = @{ lower='lowercase'; upper='UPPERCASE'; title='Title Case'; sentence='Sentence case'; camel='camelCase'; pascal='PascalCase'; snake='snake_case'; kebab='kebab-case'; constant='CONSTANT_CASE' }\n  \n  Write-XY @{ table = @{ title='Case Conversion'; header=@('Property','Value'); rows=@(@('Target Case', $caseNames[$targetCase]), @('Input', $(if ($text.Length -gt 50) { $text.Substring(0,50) + '...' } else { $text })), @('Output', $(if ($output.Length -gt 50) { $output.Substring(0,50) + '...' } else { $output }))); caption=\"Converted to $($caseNames[$targetCase])\" } }\n  [pscustomobject]@{ tool='String Case Converter'; targetCase=$targetCase; input=$text; output=$output }\n}\n\n# ------------------------- Color Converter -------------------------\nfunction Invoke-ColorConverter {\n  param($Params, $JobInput, [string]$Cwd)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $inputFormat = ($Params.colorInputFormat ?? 'hex')\n  $source = ($Params.colorSource ?? 'field')\n  $colorInput = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.colorDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $colorInput = [string]$val\n  } else { $colorInput = ($Params.colorInput ?? '') }\n  \n  if (-not $colorInput) { throw 'No color input provided' }\n  \n  Write-XYProgress 0.5 'Converting color...'\n  \n  $r = 0; $g = 0; $b = 0\n  \n  switch ($inputFormat) {\n    'hex' {\n      $hex = $colorInput -replace '^#', ''\n      if ($hex.Length -eq 3) { $hex = \"$($hex[0])$($hex[0])$($hex[1])$($hex[1])$($hex[2])$($hex[2])\" }\n      if ($hex.Length -ne 6) { throw \"Invalid HEX color: $colorInput\" }\n      $r = [Convert]::ToInt32($hex.Substring(0,2), 16)\n      $g = [Convert]::ToInt32($hex.Substring(2,2), 16)\n      $b = [Convert]::ToInt32($hex.Substring(4,2), 16)\n    }\n    'rgb' {\n      $match = [regex]::Match($colorInput, 'rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)')\n      if (-not $match.Success) {\n        $parts = $colorInput -split '[,\\s]+' | Where-Object { $_ -match '^\\d+$' }\n        if ($parts.Count -ge 3) { $r = [int]$parts[0]; $g = [int]$parts[1]; $b = [int]$parts[2] }\n        else { throw \"Invalid RGB color: $colorInput\" }\n      } else {\n        $r = [int]$match.Groups[1].Value; $g = [int]$match.Groups[2].Value; $b = [int]$match.Groups[3].Value\n      }\n    }\n    'hsl' {\n      $match = [regex]::Match($colorInput, 'hsl\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)%?\\s*,\\s*([\\d.]+)%?\\s*\\)')\n      if (-not $match.Success) {\n        $parts = $colorInput -split '[,\\s]+' | Where-Object { $_ -match '^[\\d.]+' }\n        if ($parts.Count -ge 3) { $h = [double]($parts[0] -replace '%',''); $s = [double]($parts[1] -replace '%','')/100; $l = [double]($parts[2] -replace '%','')/100 }\n        else { throw \"Invalid HSL color: $colorInput\" }\n      } else {\n        $h = [double]$match.Groups[1].Value; $s = [double]$match.Groups[2].Value/100; $l = [double]$match.Groups[3].Value/100\n      }\n      # HSL to RGB conversion\n      if ($s -eq 0) { $r = $g = $b = [int]($l * 255) }\n      else {\n        $hueToRgb = { param($p, $q, $t) if ($t -lt 0) { $t += 1 }; if ($t -gt 1) { $t -= 1 }; if ($t -lt 1/6) { return $p + ($q - $p) * 6 * $t }; if ($t -lt 1/2) { return $q }; if ($t -lt 2/3) { return $p + ($q - $p) * (2/3 - $t) * 6 }; return $p }\n        $q = if ($l -lt 0.5) { $l * (1 + $s) } else { $l + $s - $l * $s }\n        $p = 2 * $l - $q\n        $r = [int]([Math]::Round((& $hueToRgb $p $q ($h/360 + 1/3)) * 255))\n        $g = [int]([Math]::Round((& $hueToRgb $p $q ($h/360)) * 255))\n        $b = [int]([Math]::Round((& $hueToRgb $p $q ($h/360 - 1/3)) * 255))\n      }\n    }\n  }\n  \n  $r = [Math]::Max(0, [Math]::Min(255, $r)); $g = [Math]::Max(0, [Math]::Min(255, $g)); $b = [Math]::Max(0, [Math]::Min(255, $b))\n  \n  # Convert to all formats\n  $hex = '#{0:X2}{1:X2}{2:X2}' -f $r, $g, $b\n  $rgb = \"rgb($r, $g, $b)\"\n  $maxC = [Math]::Max($r, [Math]::Max($g, $b)) / 255; $minC = [Math]::Min($r, [Math]::Min($g, $b)) / 255\n  $l = ($maxC + $minC) / 2; $s = 0; $h = 0\n  if ($maxC -ne $minC) {\n    $d = $maxC - $minC\n    $s = if ($l -gt 0.5) { $d / (2 - $maxC - $minC) } else { $d / ($maxC + $minC) }\n    $rn = $r/255; $gn = $g/255; $bn = $b/255\n    if ($rn -eq $maxC) { $h = (($gn - $bn) / $d + $(if ($gn -lt $bn) { 6 } else { 0 })) * 60 }\n    elseif ($gn -eq $maxC) { $h = (($bn - $rn) / $d + 2) * 60 }\n    else { $h = (($rn - $gn) / $d + 4) * 60 }\n  }\n  $hsl = \"hsl($([Math]::Round($h)), $([Math]::Round($s * 100))%, $([Math]::Round($l * 100))%)\"\n  \n  Write-XYProgress 0.9 'Generating color swatch...'\n  \n  # Generate color swatch PNG\n  Add-Type -AssemblyName System.Drawing -ErrorAction SilentlyContinue\n  $swatchSize = 100\n  $swatch = New-Object System.Drawing.Bitmap($swatchSize, $swatchSize)\n  $graphics = [System.Drawing.Graphics]::FromImage($swatch)\n  $brush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb($r, $g, $b))\n  $graphics.FillRectangle($brush, 0, 0, $swatchSize, $swatchSize)\n  # Add border\n  $pen = New-Object System.Drawing.Pen([System.Drawing.Color]::FromArgb(200, 200, 200), 2)\n  $graphics.DrawRectangle($pen, 0, 0, $swatchSize - 1, $swatchSize - 1)\n  $brush.Dispose(); $pen.Dispose(); $graphics.Dispose()\n  \n  $filename = \"color-swatch-$($hex.Replace('#', '')).png\"\n  $filepath = Join-Path $Cwd $filename\n  $swatch.Save($filepath, [System.Drawing.Imaging.ImageFormat]::Png)\n  $swatch.Dispose()\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ files = @($filename) }\n  Write-XY @{ table = @{ title='Color Conversion'; header=@('Format','Value'); rows=@(@('HEX', $hex), @('RGB', $rgb), @('HSL', $hsl), @('Red', $r), @('Green', $g), @('Blue', $b)); caption=\"Converted from $inputFormat\" } }\n  [pscustomobject]@{ tool='Color Converter'; inputFormat=$inputFormat; input=$colorInput; hex=$hex; rgb=$rgb; hsl=$hsl; red=$r; green=$g; blue=$b; swatchFile=$filename }\n}\n\n# ------------------------- Image Converter -------------------------\nfunction Invoke-ImageConverter {\n  param($Params, $JobInput, [string]$Cwd)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $source = ($Params.imgSource ?? 'field')\n  $outputFormat = ($Params.imgOutputFormat ?? 'png')\n  $resize = ($Params.imgResize ?? 'none')\n  $width = [int]($Params.imgWidth ?? 0)\n  $height = [int]($Params.imgHeight ?? 0)\n  $inputFile = ''\n  \n  switch ($source) {\n    'files' {\n      # Get file from job input files array\n      $fileIndex = [int]($Params.imgFileIndex ?? 0)\n      if (-not $JobInput.files -or $JobInput.files.Count -eq 0) { throw 'No input files available from job' }\n      if ($fileIndex -ge $JobInput.files.Count) { throw \"File index $fileIndex out of range ($($JobInput.files.Count) files available)\" }\n      $fileObj = $JobInput.files[$fileIndex]\n      # File object has properties: id, date, filename, size, username - extract the filename\n      if ($fileObj -is [string]) {\n        $inputFile = $fileObj\n      } elseif ($fileObj.PSObject.Properties.Name -contains 'filename') {\n        $inputFile = $fileObj.filename\n      } else {\n        $inputFile = [string]$fileObj\n      }\n    }\n    'input' {\n      # Get file path from job input data\n      $inputData = $JobInput.data\n      if (-not $inputData) { throw 'No input data available from previous job' }\n      $dataPath = ($Params.imgDataPath ?? '')\n      $val = Get-NestedValue $inputData $dataPath\n      if ($null -eq $val) { throw \"Data path '$dataPath' not found in input data\" }\n      $inputFile = [string]$val\n    }\n    default {\n      # Use text field\n      $inputFile = ($Params.imgInput ?? '')\n    }\n  }\n  \n  if (-not $inputFile) { throw 'No input file specified' }\n  \n  # Ensure inputFile is a string\n  $inputFile = [string]$inputFile\n  $inputPath = if ([System.IO.Path]::IsPathRooted($inputFile)) { $inputFile } else { Join-Path $Cwd $inputFile }\n  if (-not (Test-Path $inputPath)) { throw \"Input file not found: $inputFile\" }\n  \n  Write-XYProgress 0.3 'Loading image...'\n  \n  # Load image using .NET\n  Add-Type -AssemblyName System.Drawing -ErrorAction Stop\n  $img = [System.Drawing.Image]::FromFile($inputPath)\n  $origWidth = $img.Width; $origHeight = $img.Height\n  \n  Write-XYProgress 0.5 'Processing image...'\n  \n  $newWidth = $origWidth; $newHeight = $origHeight\n  \n  if ($resize -eq 'dimensions' -and $width -gt 0 -and $height -gt 0) {\n    $newWidth = $width; $newHeight = $height\n  } elseif ($resize -eq 'width' -and $width -gt 0) {\n    $newWidth = $width; $newHeight = [int]($origHeight * ($width / $origWidth))\n  } elseif ($resize -eq 'height' -and $height -gt 0) {\n    $newHeight = $height; $newWidth = [int]($origWidth * ($height / $origHeight))\n  } elseif ($resize -eq 'percent' -and $width -gt 0) {\n    $scale = $width / 100; $newWidth = [int]($origWidth * $scale); $newHeight = [int]($origHeight * $scale)\n  }\n  \n  $outputImg = $img\n  if ($newWidth -ne $origWidth -or $newHeight -ne $origHeight) {\n    $outputImg = New-Object System.Drawing.Bitmap($newWidth, $newHeight)\n    $graphics = [System.Drawing.Graphics]::FromImage($outputImg)\n    $graphics.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic\n    $graphics.DrawImage($img, 0, 0, $newWidth, $newHeight)\n    $graphics.Dispose()\n  }\n  \n  Write-XYProgress 0.8 'Saving image...'\n  \n  $baseName = [System.IO.Path]::GetFileNameWithoutExtension($inputFile)\n  $outputFile = \"$baseName-converted.$outputFormat\"\n  $outputPath = Join-Path $Cwd $outputFile\n  \n  $format = switch ($outputFormat) {\n    'png'  { [System.Drawing.Imaging.ImageFormat]::Png }\n    'jpg'  { [System.Drawing.Imaging.ImageFormat]::Jpeg }\n    'jpeg' { [System.Drawing.Imaging.ImageFormat]::Jpeg }\n    'bmp'  { [System.Drawing.Imaging.ImageFormat]::Bmp }\n    'gif'  { [System.Drawing.Imaging.ImageFormat]::Gif }\n    'tiff' { [System.Drawing.Imaging.ImageFormat]::Tiff }\n    default { [System.Drawing.Imaging.ImageFormat]::Png }\n  }\n  \n  $outputImg.Save($outputPath, $format)\n  $fileInfo = Get-Item $outputPath\n  \n  if ($outputImg -ne $img) { $outputImg.Dispose() }\n  $img.Dispose()\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ files = @($outputFile) }\n  Write-XY @{ table = @{ title='Image Converted'; header=@('Property','Value'); rows=@(@('Input File', $inputFile), @('Output File', $outputFile), @('Original Size', \"${origWidth}x${origHeight}\"), @('New Size', \"${newWidth}x${newHeight}\"), @('Output Format', $outputFormat.ToUpper()), @('File Size', \"$($fileInfo.Length) bytes\")); caption=\"Image converted to $($outputFormat.ToUpper())\" } }\n  [pscustomobject]@{ tool='Image Converter'; inputFile=$inputFile; outputFile=$outputFile; originalWidth=$origWidth; originalHeight=$origHeight; newWidth=$newWidth; newHeight=$newHeight; outputFormat=$outputFormat; fileSize=$fileInfo.Length }\n}\n\n# ------------------------- Slug Generator -------------------------\nfunction Invoke-SlugGenerator {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.slugSource ?? 'field')\n  $separator = ($Params.slugSeparator ?? '-')\n  $lowercase = ($Params.slugLowercase ?? 'true') -eq 'true'\n  $maxLength = [int]($Params.slugMaxLength ?? 0)\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.slugDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $text = [string]$val\n  } else { $text = ($Params.slugInput ?? '') }\n  \n  if (-not $text) { throw 'No input text provided' }\n  \n  Write-XYProgress 0.5 'Generating slug...'\n  \n  # Normalize unicode and remove diacritics\n  $normalized = $text.Normalize([System.Text.NormalizationForm]::FormD)\n  $slug = ($normalized -replace '\\p{M}', '').Trim()\n  \n  # Replace non-alphanumeric with separator\n  $slug = $slug -replace '[^a-zA-Z0-9]+', $separator\n  $slug = $slug.Trim($separator)\n  \n  # Remove consecutive separators\n  $slug = $slug -replace \"[$separator]+\", $separator\n  \n  if ($lowercase) { $slug = $slug.ToLowerInvariant() }\n  if ($maxLength -gt 0 -and $slug.Length -gt $maxLength) {\n    $slug = $slug.Substring(0, $maxLength).TrimEnd($separator)\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ table = @{ title='Slug Generated'; header=@('Property','Value'); rows=@(@('Input', $(if ($text.Length -gt 50) { $text.Substring(0,50) + '...' } else { $text })), @('Slug', $slug), @('Separator', $separator), @('Lowercase', $(if ($lowercase) { 'Yes' } else { 'No' })), @('Length', $slug.Length)); caption='URL-safe slug generated' } }\n  [pscustomobject]@{ tool='Slug Generator'; input=$text; slug=$slug; separator=$separator; lowercase=$lowercase; length=$slug.Length }\n}\n\n# ------------------------- Text Statistics -------------------------\nfunction Invoke-TextStatistics {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.statsSource ?? 'field')\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.statsDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.statsInput ?? '') }\n  \n  if (-not $text) { throw 'No input text provided' }\n  \n  Write-XYProgress 0.5 'Analyzing text...'\n  \n  $charCount = $text.Length\n  $charNoSpaces = ($text -replace '\\s', '').Length\n  $words = @($text -split '\\s+' | Where-Object { $_.Length -gt 0 })\n  $wordCount = $words.Count\n  $lines = @($text -split \"`n\")\n  $lineCount = $lines.Count\n  $sentences = @($text -split '[.!?]+' | Where-Object { $_.Trim().Length -gt 0 })\n  $sentenceCount = $sentences.Count\n  $paragraphs = @($text -split \"`n\\s*`n\" | Where-Object { $_.Trim().Length -gt 0 })\n  $paragraphCount = $paragraphs.Count\n  \n  # Average word length\n  $avgWordLength = if ($wordCount -gt 0) { [Math]::Round(($words | ForEach-Object { $_.Length } | Measure-Object -Average).Average, 1) } else { 0 }\n  \n  # Reading time (200 words/minute)\n  $readingMinutes = [Math]::Ceiling($wordCount / 200)\n  \n  # Speaking time (150 words/minute)\n  $speakingMinutes = [Math]::Ceiling($wordCount / 150)\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ table = @{ title='Text Statistics'; header=@('Metric','Value'); rows=@(@('Characters', $charCount), @('Characters (no spaces)', $charNoSpaces), @('Words', $wordCount), @('Sentences', $sentenceCount), @('Paragraphs', $paragraphCount), @('Lines', $lineCount), @('Avg Word Length', \"$avgWordLength chars\"), @('Reading Time', \"~$readingMinutes min\"), @('Speaking Time', \"~$speakingMinutes min\")); caption='Text analysis complete' } }\n  [pscustomobject]@{ tool='Text Statistics'; characters=$charCount; charactersNoSpaces=$charNoSpaces; words=$wordCount; sentences=$sentenceCount; paragraphs=$paragraphCount; lines=$lineCount; avgWordLength=$avgWordLength; readingMinutes=$readingMinutes; speakingMinutes=$speakingMinutes }\n}\n\n# ------------------------- Credit Card Validator -------------------------\nfunction Invoke-CreditCardValidator {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.ccSource ?? 'field')\n  $cardNumber = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.ccDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $cardNumber = [string]$val\n  } else { $cardNumber = ($Params.ccInput ?? '') }\n  \n  if (-not $cardNumber) { throw 'No card number provided' }\n  \n  Write-XYProgress 0.5 'Validating card...'\n  \n  # Remove spaces, dashes\n  $cleaned = $cardNumber -replace '[\\s-]', ''\n  \n  # Check if numeric only\n  if ($cleaned -notmatch '^\\d+$') { throw 'Card number must contain only digits' }\n  \n  # Luhn algorithm validation\n  $digits = $cleaned.ToCharArray() | ForEach-Object { [int]::Parse($_) }\n  $sum = 0; $alt = $false\n  for ($i = $digits.Length - 1; $i -ge 0; $i--) {\n    $d = $digits[$i]\n    if ($alt) { $d *= 2; if ($d -gt 9) { $d -= 9 } }\n    $sum += $d; $alt = -not $alt\n  }\n  $isValid = ($sum % 10) -eq 0\n  \n  # Detect card type by prefix and length\n  $cardType = 'Unknown'\n  $len = $cleaned.Length\n  if ($cleaned -match '^4' -and ($len -eq 13 -or $len -eq 16 -or $len -eq 19)) { $cardType = 'Visa' }\n  elseif ($cleaned -match '^5[1-5]' -and $len -eq 16) { $cardType = 'Mastercard' }\n  elseif ($cleaned -match '^(34|37)' -and $len -eq 15) { $cardType = 'American Express' }\n  elseif ($cleaned -match '^6(?:011|5)' -and $len -eq 16) { $cardType = 'Discover' }\n  elseif ($cleaned -match '^3(?:0[0-5]|[68])' -and ($len -eq 14 -or $len -eq 16)) { $cardType = \"Diners Club\" }\n  elseif ($cleaned -match '^35(?:2[89]|[3-8])' -and ($len -ge 16 -and $len -le 19)) { $cardType = 'JCB' }\n  elseif ($cleaned -match '^62' -and $len -eq 16) { $cardType = 'UnionPay' }\n  \n  # Mask card number\n  $masked = if ($len -ge 8) { $cleaned.Substring(0,4) + ('*' * ($len - 8)) + $cleaned.Substring($len - 4) } else { '*' * $len }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $validText = if ($isValid) { '[OK] Valid (Luhn check passed)' } else { '[X] Invalid (Luhn check failed)' }\n  Write-XY @{ table = @{ title='Credit Card Validation'; header=@('Property','Value'); rows=@(@('Masked Number', $masked), @('Card Type', $cardType), @('Valid', $validText), @('Length', $len)); caption=$(if ($isValid) { 'Card number is valid' } else { 'Card number is invalid' }) } }\n  [pscustomobject]@{ tool='Credit Card Validator'; maskedNumber=$masked; cardType=$cardType; valid=$isValid; length=$len }\n}\n\n# ------------------------- Email Validator -------------------------\nfunction Invoke-EmailValidator {\n  param($Params, $JobInput)\n  Write-XYProgress 0.1 'Validating parameters...'\n  $source = ($Params.emailSource ?? 'field')\n  $email = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $path = ($Params.emailDataPath ?? '')\n    $val = Get-NestedValue $inputData $path\n    if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n    $email = [string]$val\n  } else { $email = ($Params.emailInput ?? '') }\n  \n  if (-not $email) { throw 'No email address provided' }\n  \n  Write-XYProgress 0.5 'Validating email...'\n  \n  $email = $email.Trim()\n  $isValid = $false; $localPart = ''; $domain = ''; $tld = ''\n  $issues = [System.Collections.Generic.List[string]]::new()\n  \n  # RFC 5322 simplified regex\n  $emailRegex = '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'\n  \n  if ($email -match '@') {\n    $parts = $email -split '@'\n    if ($parts.Count -eq 2) {\n      $localPart = $parts[0]; $domain = $parts[1]\n      if ($domain -match '\\.([a-zA-Z]{2,})$') { $tld = $Matches[1] }\n    }\n  }\n  \n  if ($email -match $emailRegex) {\n    $isValid = $true\n    if ($localPart.Length -gt 64) { $issues.Add('Local part exceeds 64 chars'); $isValid = $false }\n    if ($domain.Length -gt 253) { $issues.Add('Domain exceeds 253 chars'); $isValid = $false }\n    if ($localPart.StartsWith('.') -or $localPart.EndsWith('.')) { $issues.Add('Local part starts/ends with dot'); $isValid = $false }\n    if ($localPart -match '\\.\\.') { $issues.Add('Local part has consecutive dots'); $isValid = $false }\n  } else {\n    if (-not ($email -match '@')) { $issues.Add('Missing @ symbol') }\n    elseif ($parts.Count -ne 2) { $issues.Add('Multiple @ symbols') }\n    elseif (-not $localPart) { $issues.Add('Empty local part') }\n    elseif (-not $domain) { $issues.Add('Empty domain') }\n    elseif (-not ($domain -match '\\.')) { $issues.Add('Domain missing TLD') }\n    else { $issues.Add('Invalid format') }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $validText = if ($isValid) { '[OK] Valid' } else { '[X] Invalid' }\n  $issueText = if ($issues.Count -gt 0) { $issues -join '; ' } else { 'None' }\n  Write-XY @{ table = @{ title='Email Validation'; header=@('Property','Value'); rows=@(@('Email', $email), @('Valid', $validText), @('Local Part', $(if ($localPart) { $localPart } else { 'N/A' })), @('Domain', $(if ($domain) { $domain } else { 'N/A' })), @('TLD', $(if ($tld) { $tld } else { 'N/A' })), @('Issues', $issueText)); caption=$(if ($isValid) { 'Email address is valid' } else { 'Email address is invalid' }) } }\n  [pscustomobject]@{ tool='Email Validator'; email=$email; valid=$isValid; localPart=$localPart; domain=$domain; tld=$tld; issues=$issues.ToArray() }\n}\n\n\n# ------------------------- Barcode Generator -------------------------\nfunction Invoke-BarcodeGenerator {\n  param($Params, $JobInput, [string]$Cwd)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $barcodeType = ($Params.barcodeType ?? 'code128')\n  $source = ($Params.barcodeSource ?? 'field')\n  $text = ''\n  \n  if ($source -eq 'input') {\n    $inputData = $JobInput.data\n    if (-not $inputData) { throw 'No input data available from previous job' }\n    $dataPath = ($Params.barcodeDataPath ?? '')\n    $val = Get-NestedValue $inputData $dataPath\n    if ($null -eq $val) { throw \"Data path '$dataPath' not found in input data\" }\n    $text = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n  } else { $text = ($Params.barcodeText ?? '') }\n  \n  if (-not $text) { throw 'No barcode text provided' }\n  \n  Write-XYProgress 0.5 'Generating barcode...'\n  \n  $svg = ''\n  $filename = \"barcode-$barcodeType.svg\"\n  \n  switch ($barcodeType) {\n    'code128' {\n      # Code 128 encoding (subset B for printable ASCII) - use case-sensitive hashtable\n      $patterns = [System.Collections.Hashtable]::new([StringComparer]::Ordinal)\n      # Special characters and numbers\n      $patterns[' ']='11011001100'; $patterns['!']='11001101100'; $patterns['\"']='11001100110'\n      $patterns['#']='10010011000'; $patterns['$']='10010001100'; $patterns['%']='10001001100'\n      $patterns['&']='10011001000'; $patterns[\"'\"]='10011000100'; $patterns['(']='10001100100'\n      $patterns[')']='11001001000'; $patterns['*']='11001000100'; $patterns['+']='11000100100'\n      $patterns[',']='10110011100'; $patterns['-']='10011011100'; $patterns['.']='10011001110'\n      $patterns['/']='10111001100'; $patterns['0']='10011101100'; $patterns['1']='10011100110'\n      $patterns['2']='11001110010'; $patterns['3']='11001011100'; $patterns['4']='11001001110'\n      $patterns['5']='11011100100'; $patterns['6']='11001110100'; $patterns['7']='11101101110'\n      $patterns['8']='11101001100'; $patterns['9']='11100101100'; $patterns[':']='11100100110'\n      $patterns[';']='11101100100'; $patterns['<']='11100110100'; $patterns['=']='11100110010'\n      $patterns['>']='11011011000'; $patterns['?']='11011000110'; $patterns['@']='11000110110'\n      # Uppercase letters\n      $patterns['A']='10100011000'; $patterns['B']='10001011000'; $patterns['C']='10001000110'\n      $patterns['D']='10110001000'; $patterns['E']='10001101000'; $patterns['F']='10001100010'\n      $patterns['G']='11010001000'; $patterns['H']='11000101000'; $patterns['I']='11000100010'\n      $patterns['J']='10110111000'; $patterns['K']='10110001110'; $patterns['L']='10001101110'\n      $patterns['M']='10111011000'; $patterns['N']='10111000110'; $patterns['O']='10001110110'\n      $patterns['P']='11101110110'; $patterns['Q']='11010001110'; $patterns['R']='11000101110'\n      $patterns['S']='11011101000'; $patterns['T']='11011100010'; $patterns['U']='11011101110'\n      $patterns['V']='11101011000'; $patterns['W']='11101000110'; $patterns['X']='11100010110'\n      $patterns['Y']='11101101000'; $patterns['Z']='11101100010'; $patterns['[']='11100011010'\n      $patterns['\\']='11101111010'; $patterns[']']='11001000010'; $patterns['^']='11110001010'\n      $patterns['_']='10100110000'; $patterns['`']='10100001100'\n      # Lowercase letters\n      $patterns['a']='10010110000'; $patterns['b']='10010000110'; $patterns['c']='10000101100'\n      $patterns['d']='10000100110'; $patterns['e']='10110010000'; $patterns['f']='10110000100'\n      $patterns['g']='10011010000'; $patterns['h']='10011000010'; $patterns['i']='10000110100'\n      $patterns['j']='10000110010'; $patterns['k']='11000010010'; $patterns['l']='11001010000'\n      $patterns['m']='11110111010'; $patterns['n']='11000010100'; $patterns['o']='10001111010'\n      $patterns['p']='10100111100'; $patterns['q']='10010111100'; $patterns['r']='10010011110'\n      $patterns['s']='10111100100'; $patterns['t']='10011110100'; $patterns['u']='10011110010'\n      $patterns['v']='11110100100'; $patterns['w']='11110010100'; $patterns['x']='11110010010'\n      $patterns['y']='11011011110'; $patterns['z']='11011110110'; $patterns['{']='11110110110'\n      $patterns['|']='10101111000'; $patterns['}']='10100011110'; $patterns['~']='10001011110'\n      $startB = '11010010000'; $stop = '1100011101011'\n      $checksum = 104 # Start B value\n      $encoded = $startB\n      for ($i = 0; $i -lt $text.Length; $i++) {\n        $c = $text[$i]\n        if ($patterns.ContainsKey([string]$c)) {\n          $encoded += $patterns[[string]$c]\n          $val = [int][char]$c - 32\n          $checksum += $val * ($i + 1)\n        }\n      }\n      $checkVal = $checksum % 103\n      $checkChar = [char]($checkVal + 32)\n      if ($patterns.ContainsKey([string]$checkChar)) { $encoded += $patterns[[string]$checkChar] }\n      $encoded += $stop\n      \n      # Generate SVG\n      $barWidth = 2; $height = 80; $width = $encoded.Length * $barWidth + 20\n      $svg = \"<svg xmlns='http://www.w3.org/2000/svg' width='$width' height='$($height + 30)' viewBox='0 0 $width $($height + 30)'>\"\n      $svg += \"<rect width='100%' height='100%' fill='white'/>\"\n      $x = 10\n      foreach ($bit in $encoded.ToCharArray()) {\n        if ($bit -eq '1') { $svg += \"<rect x='$x' y='10' width='$barWidth' height='$height' fill='black'/>\" }\n        $x += $barWidth\n      }\n      $svg += \"<text x='$($width/2)' y='$($height + 25)' text-anchor='middle' font-family='monospace' font-size='12'>$([System.Security.SecurityElement]::Escape($text))</text>\"\n      $svg += \"</svg>\"\n    }\n    'code39' {\n      $patterns = @{\n        '0'='101001101101'; '1'='110100101011'; '2'='101100101011'; '3'='110110010101'; '4'='101001101011'\n        '5'='110100110101'; '6'='101100110101'; '7'='101001011011'; '8'='110100101101'; '9'='101100101101'\n        'A'='110101001011'; 'B'='101101001011'; 'C'='110110100101'; 'D'='101011001011'; 'E'='110101100101'\n        'F'='101101100101'; 'G'='101010011011'; 'H'='110101001101'; 'I'='101101001101'; 'J'='101011001101'\n        'K'='110101010011'; 'L'='101101010011'; 'M'='110110101001'; 'N'='101011010011'; 'O'='110101101001'\n        'P'='101101101001'; 'Q'='101010110011'; 'R'='110101011001'; 'S'='101101011001'; 'T'='101011011001'\n        'U'='110010101011'; 'V'='100110101011'; 'W'='110011010101'; 'X'='100101101011'; 'Y'='110010110101'\n        'Z'='100110110101'; '-'='100101011011'; '.'='110010101101'; ' '='100110101101'; '*'='100101101101'\n        '$'='100100100101'; '/'='100100101001'; '+'='100101001001'; '%'='101001001001'\n      }\n      $textUpper = \"*$($text.ToUpper())*\"\n      $encoded = ''\n      foreach ($c in $textUpper.ToCharArray()) {\n        if ($patterns.ContainsKey([string]$c)) { $encoded += $patterns[[string]$c] + '0' }\n      }\n      \n      $barWidth = 2; $height = 80; $width = $encoded.Length * $barWidth + 20\n      $svg = \"<svg xmlns='http://www.w3.org/2000/svg' width='$width' height='$($height + 30)' viewBox='0 0 $width $($height + 30)'>\"\n      $svg += \"<rect width='100%' height='100%' fill='white'/>\"\n      $x = 10\n      foreach ($bit in $encoded.ToCharArray()) {\n        if ($bit -eq '1') { $svg += \"<rect x='$x' y='10' width='$barWidth' height='$height' fill='black'/>\" }\n        $x += $barWidth\n      }\n      $svg += \"<text x='$($width/2)' y='$($height + 25)' text-anchor='middle' font-family='monospace' font-size='12'>$([System.Security.SecurityElement]::Escape($text.ToUpper()))</text>\"\n      $svg += \"</svg>\"\n    }\n  }\n  \n  Write-XYProgress 0.7 'Saving SVG...'\n  \n  $svgFilename = \"barcode-$barcodeType.svg\"\n  $pngFilename = \"barcode-$barcodeType.png\"\n  $svgPath = Join-Path $Cwd $svgFilename\n  $pngPath = Join-Path $Cwd $pngFilename\n  \n  $svg | Out-File -FilePath $svgPath -Encoding UTF8 -NoNewline\n  \n  Write-XYProgress 0.85 'Generating PNG...'\n  \n  # Generate PNG using System.Drawing\n  Add-Type -AssemblyName System.Drawing -ErrorAction SilentlyContinue\n  $barWidth = 2\n  $height = 80\n  $margin = 10\n  $textHeight = 25\n  $imgWidth = $encoded.Length * $barWidth + ($margin * 2)\n  $imgHeight = $height + $margin + $textHeight\n  \n  $bitmap = New-Object System.Drawing.Bitmap($imgWidth, $imgHeight)\n  $graphics = [System.Drawing.Graphics]::FromImage($bitmap)\n  $graphics.Clear([System.Drawing.Color]::White)\n  \n  # Draw bars\n  $blackBrush = [System.Drawing.Brushes]::Black\n  $x = $margin\n  foreach ($bit in $encoded.ToCharArray()) {\n    if ($bit -eq '1') {\n      $graphics.FillRectangle($blackBrush, $x, $margin, $barWidth, $height)\n    }\n    $x += $barWidth\n  }\n  \n  # Draw text\n  $font = New-Object System.Drawing.Font('Consolas', 10)\n  $textBrush = [System.Drawing.Brushes]::Black\n  $displayText = if ($barcodeType -eq 'code39') { $text.ToUpper() } else { $text }\n  $textSize = $graphics.MeasureString($displayText, $font)\n  $textX = ($imgWidth - $textSize.Width) / 2\n  $textY = $margin + $height + 5\n  $graphics.DrawString($displayText, $font, $textBrush, $textX, $textY)\n  \n  $font.Dispose()\n  $graphics.Dispose()\n  $bitmap.Save($pngPath, [System.Drawing.Imaging.ImageFormat]::Png)\n  $bitmap.Dispose()\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  Write-XY @{ files = @($svgFilename, $pngFilename) }\n  Write-XY @{ table = @{ title='Barcode Generated'; header=@('Property','Value'); rows=@(@('Type', $barcodeType.ToUpper()), @('Text', $text), @('SVG File', $svgFilename), @('PNG File', $pngFilename)); caption='Barcode generated as SVG and PNG' } }\n  [pscustomobject]@{ tool='Barcode Generator'; type=$barcodeType; text=$text; svgFile=$svgFilename; pngFile=$pngFilename; files=@($svgFilename, $pngFilename) }\n}\n\n# ------------------------- Fake Data Generator -------------------------\nfunction Invoke-FakeDataGenerator {\n  param($Params)\n  Write-XYProgress 0.1 'Validating parameters...'\n  \n  $dataType = ($Params.fakeDataType ?? 'person')\n  $country = ($Params.fakeCountry ?? 'us')\n  $count = [int]($Params.fakeCount ?? 1)\n  $count = [Math]::Max(1, [Math]::Min($count, 100))\n  \n  Write-XYProgress 0.2 'Loading country data...'\n  \n  # Country-specific data pools\n  $countryData = @{\n    'us' = @{\n      countryName = 'United States'\n      countryCode = 'US'\n      firstNames = @('James','Mary','John','Patricia','Robert','Jennifer','Michael','Linda','David','Elizabeth','William','Barbara','Richard','Susan','Joseph','Jessica','Thomas','Sarah','Christopher','Karen','Charles','Lisa','Daniel','Nancy','Matthew','Betty','Anthony','Margaret','Mark','Sandra')\n      lastNames = @('Smith','Johnson','Williams','Brown','Jones','Garcia','Miller','Davis','Rodriguez','Martinez','Wilson','Anderson','Thomas','Taylor','Moore','Jackson','Martin','Lee','Thompson','White','Harris','Clark','Lewis','Robinson','Walker','Young','Allen','King','Wright','Scott')\n      streets = @('Main St','Oak Ave','Maple Dr','Cedar Ln','Pine Rd','Elm St','Park Ave','Lake Dr','Hill Rd','River Rd','Forest Ave','Valley Dr','Sunset Blvd','Ocean Ave','Mountain Rd')\n      cities = @('New York','Los Angeles','Chicago','Houston','Phoenix','Philadelphia','San Antonio','San Diego','Dallas','Austin','Seattle','Denver','Boston','Miami','Atlanta')\n      regions = @('NY','CA','IL','TX','AZ','PA','FL','OH','NC','WA','CO','MA','GA','MI','NJ')\n      regionLabel = 'State'\n      postalFormat = { '{0:D5}' -f ((Get-Random -Maximum 90000) + 10000) }\n      phoneFormat = { '+1 ({0:D3}) {1:D3}-{2:D4}' -f ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 9000)+1000) }\n      mobileFormat = { '+1 ({0:D3}) {1:D3}-{2:D4}' -f ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 9000)+1000) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$num $street, $city, $region $postal\" }\n      companies = @('Acme Corp','Global Tech','Innovative Solutions','Digital Dynamics','Future Systems','Prime Industries','Elite Services','Apex Group','Pinnacle Inc','Quantum Labs')\n    }\n    'uk' = @{\n      countryName = 'United Kingdom'\n      countryCode = 'GB'\n      firstNames = @('Oliver','Olivia','George','Amelia','Harry','Isla','Noah','Ava','Jack','Emily','Leo','Mia','Charlie','Grace','Oscar','Lily','Henry','Sophie','William','Ella','Thomas','Freya','James','Charlotte','Jacob','Ivy','Arthur','Daisy','Alfie','Poppy')\n      lastNames = @('Smith','Jones','Williams','Taylor','Brown','Davies','Evans','Wilson','Thomas','Roberts','Johnson','Lewis','Walker','Robinson','Wood','Thompson','White','Watson','Jackson','Wright','Green','Harris','Cooper','King','Lee','Martin','Clarke','James','Morgan','Hughes')\n      streets = @('High Street','Church Lane','Station Road','Mill Lane','The Green','Park Road','Victoria Road','Manor Road','Queens Road','Kings Road','London Road','Bridge Street','Market Street','Chapel Lane','School Lane')\n      cities = @('London','Birmingham','Manchester','Leeds','Liverpool','Sheffield','Bristol','Newcastle','Nottingham','Southampton','Edinburgh','Glasgow','Cardiff','Belfast','Cambridge','Oxford','Brighton','Bath')\n      regions = @('Greater London','West Midlands','Greater Manchester','West Yorkshire','Merseyside','South Yorkshire','Avon','Tyne and Wear','Nottinghamshire','Hampshire','Lothian','Strathclyde','South Glamorgan','Antrim','Cambridgeshire')\n      regionLabel = 'County'\n      postalFormat = { $letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; \"$($letters[(Get-Random -Maximum 26)])$($letters[(Get-Random -Maximum 26)])$((Get-Random -Maximum 9)+1) $((Get-Random -Maximum 9)+1)$($letters[(Get-Random -Maximum 26)])$($letters[(Get-Random -Maximum 26)])\" }\n      phoneFormat = { '+44 {0:D4} {1:D6}' -f ((Get-Random -Maximum 9000)+1000), ((Get-Random -Maximum 900000)+100000) }\n      mobileFormat = { '+44 7{0:D3} {1:D6}' -f ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 900000)+100000) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$num $street`n$city`n$postal\" }\n      companies = @('British Solutions Ltd','Crown Industries','Royal Tech','Empire Group','Commonwealth Corp','Sterling Services','Albion Partners','Thames Digital','Windsor Holdings','Cambridge Innovations')\n    }\n    'de' = @{\n      countryName = 'Germany'\n      countryCode = 'DE'\n      firstNames = @('Lukas','Emma','Leon','Mia','Paul','Hannah','Felix','Sophia','Maximilian','Marie','Jonas','Emilia','Ben','Lina','Elias','Anna','Noah','Lea','Luis','Clara','Tim','Laura','Finn','Lena','Julian','Sarah','Niklas','Julia','Moritz','Amelie')\n      lastNames = @('Mueller','Schmidt','Schneider','Fischer','Weber','Meyer','Wagner','Becker','Schulz','Hoffmann','Schaefer','Koch','Bauer','Richter','Klein','Wolf','Schroeder','Neumann','Schwarz','Zimmermann','Braun','Krueger','Hofmann','Hartmann','Lange','Schmitt','Werner','Krause','Meier','Lehmann')\n      streets = @('Hauptstrasse','Bahnhofstrasse','Schulstrasse','Gartenstrasse','Dorfstrasse','Bergstrasse','Kirchstrasse','Waldstrasse','Ringstrasse','Muehlenweg','Lindenstrasse','Rosenweg','Birkenweg','Ahornweg','Eichenstrasse')\n      cities = @('Berlin','Hamburg','Munich','Cologne','Frankfurt','Stuttgart','Dusseldorf','Leipzig','Dortmund','Essen','Bremen','Dresden','Hanover','Nuremberg','Duisburg')\n      regions = @('Berlin','Hamburg','Bavaria','North Rhine-Westphalia','Hesse','Baden-Wuerttemberg','Lower Saxony','Saxony','Rhineland-Palatinate','Schleswig-Holstein','Brandenburg','Saxony-Anhalt','Thuringia','Mecklenburg-Vorpommern','Saarland')\n      regionLabel = 'Bundesland'\n      postalFormat = { '{0:D5}' -f ((Get-Random -Maximum 90000) + 10000) }\n      phoneFormat = { '+49 {0:D3} {1:D7}' -f ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 9000000)+1000000) }\n      mobileFormat = { $prefix = @('151','152','157','160','170','171','172','173','174','175','176','177','178','179')[(Get-Random -Maximum 14)]; '+49 {0} {1:D7}' -f $prefix, ((Get-Random -Maximum 9000000)+1000000) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$street $num`n$postal $city\" }\n      companies = @('Deutsche Technik GmbH','Berliner Solutions','Rhein Industries AG','Alpen Group','Schwarzwald Digital','Bayern Systems','Hamburg Innovations','Muenchen Partners','Dresden Tech','Leipzig Consulting')\n    }\n    'fr' = @{\n      countryName = 'France'\n      countryCode = 'FR'\n      firstNames = @('Gabriel','Emma','Louis','Jade','Raphael','Louise','Leo','Alice','Adam','Chloe','Lucas','Lina','Hugo','Rose','Jules','Lea','Arthur','Anna','Nathan','Mila','Liam','Amelia','Ethan','Manon','Paul','Juliette','Noah','Camille','Tom','Ines')\n      lastNames = @('Martin','Bernard','Dubois','Thomas','Robert','Richard','Petit','Durand','Leroy','Moreau','Simon','Laurent','Lefebvre','Michel','Garcia','David','Bertrand','Roux','Vincent','Fournier','Morel','Girard','Andre','Lefevre','Mercier','Dupont','Lambert','Bonnet','Francois','Martinez')\n      streets = @('Rue de la Paix','Avenue des Champs','Boulevard Saint-Michel','Rue du Commerce','Place de la Republique','Rue Victor Hugo','Avenue de la Gare','Rue Pasteur','Boulevard Voltaire','Rue Jean Jaures','Rue de la Liberte','Avenue Gambetta','Rue du Moulin','Place du Marche','Rue des Fleurs')\n      cities = @('Paris','Marseille','Lyon','Toulouse','Nice','Nantes','Strasbourg','Montpellier','Bordeaux','Lille','Rennes','Reims','Toulon','Grenoble','Dijon')\n      regions = @('Ile-de-France','Provence-Alpes-Cote d Azur','Auvergne-Rhone-Alpes','Occitanie','Hauts-de-France','Nouvelle-Aquitaine','Grand Est','Pays de la Loire','Bretagne','Normandie','Bourgogne-Franche-Comte','Centre-Val de Loire','Corse')\n      regionLabel = 'Region'\n      postalFormat = { '{0:D5}' -f ((Get-Random -Maximum 90000) + 10000) }\n      phoneFormat = { '+33 {0:D1} {1:D2} {2:D2} {3:D2} {4:D2}' -f ((Get-Random -Maximum 4)+1), (Get-Random -Maximum 100), (Get-Random -Maximum 100), (Get-Random -Maximum 100), (Get-Random -Maximum 100) }\n      mobileFormat = { $prefix = @(6,7)[(Get-Random -Maximum 2)]; '+33 {0} {1:D2} {2:D2} {3:D2} {4:D2}' -f $prefix, (Get-Random -Maximum 100), (Get-Random -Maximum 100), (Get-Random -Maximum 100), (Get-Random -Maximum 100) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$num $street`n$postal $city\" }\n      companies = @('Solutions Francaises SA','Paris Tech','Groupe Lyonnais','Bordeaux Industries','Marseille Digital','Toulouse Innovations','Nice Services','Nantes Partners','Strasbourg Consulting','Lyon Systems')\n    }\n    'nl' = @{\n      countryName = 'Netherlands'\n      countryCode = 'NL'\n      firstNames = @('Daan','Emma','Sem','Julia','Lucas','Tess','Levi','Sophie','Finn','Evi','Noah','Anna','Luuk','Saar','Milan','Lotte','Jesse','Noor','Bram','Fleur','Jayden','Mila','Tim','Sara','Lars','Isa','Thijs','Zoey','Ruben','Lieke')\n      lastNames = @('De Jong','Jansen','De Vries','Van den Berg','Van Dijk','Bakker','Janssen','Visser','Smit','Meijer','De Boer','Mulder','De Groot','Bos','Vos','Peters','Hendriks','Van Leeuwen','Dekker','Brouwer','De Wit','Dijkstra','Smits','De Graaf','Van der Meer')\n      streets = @('Hoofdstraat','Kerkstraat','Dorpsstraat','Stationsweg','Molenweg','Schoolstraat','Julianastraat','Beatrixstraat','Marktplein','Nieuwstraat','Oranjestraat','Wilhelminastraat','Raadhuisstraat','Gravenstraat','Havenstraat')\n      cities = @('Amsterdam','Rotterdam','The Hague','Utrecht','Eindhoven','Groningen','Tilburg','Almere','Breda','Nijmegen','Apeldoorn','Haarlem','Arnhem','Enschede','Amersfoort')\n      regions = @('North Holland','South Holland','Utrecht','North Brabant','Gelderland','Overijssel','Limburg','Friesland','Groningen','Drenthe','Flevoland','Zeeland')\n      regionLabel = 'Province'\n      postalFormat = { $letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; '{0:D4} {1}{2}' -f ((Get-Random -Maximum 9000)+1000), $letters[(Get-Random -Maximum 26)], $letters[(Get-Random -Maximum 26)] }\n      phoneFormat = { '+31 {0:D2} {1:D3} {2:D4}' -f ((Get-Random -Maximum 90)+10), ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 9000)+1000) }\n      mobileFormat = { '+31 6 {0:D8}' -f ((Get-Random -Maximum 90000000)+10000000) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$street $num`n$postal $city\" }\n      companies = @('Dutch Solutions BV','Amsterdam Tech','Rotterdam Industries','Utrecht Digital','Eindhoven Innovations','Holland Group','Nederlandse Partners','Tulip Systems','Oranje Consulting','Windmill Corp')\n    }\n    'be' = @{\n      countryName = 'Belgium'\n      countryCode = 'BE'\n      firstNames = @('Noah','Emma','Liam','Louise','Lucas','Marie','Louis','Olivia','Adam','Elise','Arthur','Anna','Jules','Charlotte','Victor','Juliette','Nathan','Camille','Mathis','Lea','Rayan','Lina','Mohamed','Elena','Aaron','Noor','Maxime','Julie','Tom','Laura')\n      lastNames = @('Peeters','Janssens','Maes','Jacobs','Mertens','Willems','Claes','Goossens','Wouters','De Smedt','Dubois','Lambert','Martin','Dupont','Simon','Laurent','Leroy','Claessens','Hermans','Van den Berg','Michiels','Leclercq','Desmet','De Backer','Hendrickx')\n      streets = @('Kerkstraat','Stationsstraat','Schoolstraat','Nieuwstraat','Molenstraat','Hoogstraat','Dorpsstraat','Groenstraat','Kapelstraat','Beekstraat','Rue de la Station','Rue du Moulin','Grand Place','Rue Haute','Chaussee de Bruxelles')\n      cities = @('Brussels','Antwerp','Ghent','Charleroi','Liege','Bruges','Namur','Leuven','Mons','Mechelen','Aalst','La Louviere','Kortrijk','Hasselt','Ostend')\n      regions = @('Brussels Capital','Antwerp','East Flanders','Hainaut','Liege','West Flanders','Namur','Flemish Brabant','Limbourg','Walloon Brabant','Luxembourg')\n      regionLabel = 'Province'\n      postalFormat = { '{0:D4}' -f ((Get-Random -Maximum 9000) + 1000) }\n      phoneFormat = { '+32 {0:D1} {1:D3} {2:D2} {3:D2}' -f ((Get-Random -Maximum 8)+2), ((Get-Random -Maximum 900)+100), (Get-Random -Maximum 100), (Get-Random -Maximum 100) }\n      mobileFormat = { $prefix = @('470','471','472','473','474','475','476','477','478','479','484','485','486','487','488','489','490','491','492','493','494','495','496','497','498','499')[(Get-Random -Maximum 26)]; '+32 {0} {1:D2} {2:D2} {3:D2}' -f $prefix, (Get-Random -Maximum 100), (Get-Random -Maximum 100), (Get-Random -Maximum 100) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$street $num`n$postal $city\" }\n      companies = @('Belgian Solutions NV','Brussels Tech','Antwerp Industries','Ghent Digital','Flemish Group','Wallonia Partners','Benelux Corp','Leuven Innovations','Bruges Consulting','Liege Systems')\n    }\n    'es' = @{\n      countryName = 'Spain'\n      countryCode = 'ES'\n      firstNames = @('Hugo','Lucia','Martin','Sofia','Lucas','Maria','Mateo','Martina','Leo','Paula','Daniel','Valeria','Pablo','Emma','Alejandro','Julia','Manuel','Daniela','Adrian','Alba','Alvaro','Carla','David','Sara','Diego','Noa','Mario','Carmen','Iker','Elena')\n      lastNames = @('Garcia','Rodriguez','Martinez','Lopez','Gonzalez','Hernandez','Perez','Sanchez','Ramirez','Torres','Flores','Rivera','Gomez','Diaz','Reyes','Morales','Jimenez','Ruiz','Alvarez','Romero','Navarro','Dominguez','Vazquez','Ramos','Gil','Serrano','Blanco','Molina','Moreno','Ortiz')\n      streets = @('Calle Mayor','Avenida de la Constitucion','Paseo del Prado','Calle Real','Plaza Mayor','Calle del Sol','Avenida de la Libertad','Calle de la Paz','Rambla de Catalunya','Gran Via','Calle Nueva','Paseo Maritimo','Calle del Carmen','Avenida del Mar','Calle San Antonio')\n      cities = @('Madrid','Barcelona','Valencia','Seville','Zaragoza','Malaga','Murcia','Palma','Las Palmas','Bilbao','Alicante','Cordoba','Valladolid','Vigo','Gijon')\n      regions = @('Community of Madrid','Catalonia','Valencian Community','Andalusia','Aragon','Balearic Islands','Canary Islands','Basque Country','Galicia','Castile and Leon','Castile-La Mancha','Region of Murcia','Navarre','Asturias','Cantabria')\n      regionLabel = 'Autonomous Community'\n      postalFormat = { '{0:D5}' -f ((Get-Random -Maximum 53000) + 1000) }\n      phoneFormat = { '+34 9{0:D2} {1:D3} {2:D3}' -f ((Get-Random -Maximum 90)+10), ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 900)+100) }\n      mobileFormat = { $prefix = @(6,7)[(Get-Random -Maximum 2)]; '+34 {0}{1:D2} {2:D3} {3:D3}' -f $prefix, ((Get-Random -Maximum 90)+10), ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 900)+100) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$street, $num`n$postal $city\" }\n      companies = @('Soluciones Espanolas SL','Madrid Tech','Barcelona Industries','Valencia Digital','Iberia Group','Costa Partners','Hispania Corp','Sevilla Innovations','Mediterraneo Consulting','Pirineos Systems')\n    }\n    'it' = @{\n      countryName = 'Italy'\n      countryCode = 'IT'\n      firstNames = @('Leonardo','Sofia','Francesco','Aurora','Alessandro','Giulia','Lorenzo','Ginevra','Mattia','Alice','Andrea','Emma','Gabriele','Giorgia','Riccardo','Beatrice','Tommaso','Chiara','Edoardo','Anna','Federico','Sara','Luca','Greta','Marco','Martina','Davide','Ludovica','Giuseppe','Francesca')\n      lastNames = @('Rossi','Russo','Ferrari','Esposito','Bianchi','Romano','Colombo','Ricci','Marino','Greco','Bruno','Gallo','Conti','De Luca','Costa','Giordano','Mancini','Rizzo','Lombardi','Moretti','Barbieri','Fontana','Santoro','Mariani','Rinaldi','Caruso','Ferrara','Galli','Martini','Leone')\n      streets = @('Via Roma','Corso Italia','Via Garibaldi','Via Dante','Piazza del Duomo','Via Mazzini','Via Vittorio Emanuele','Via Nazionale','Via della Repubblica','Via Verdi','Corso Vittorio Emanuele','Via Cavour','Via XX Settembre','Via dei Mille','Piazza della Liberta')\n      cities = @('Rome','Milan','Naples','Turin','Palermo','Genoa','Bologna','Florence','Bari','Catania','Venice','Verona','Messina','Padua','Trieste')\n      regions = @('Lazio','Lombardy','Campania','Piedmont','Sicily','Liguria','Emilia-Romagna','Tuscany','Apulia','Veneto','Friuli Venezia Giulia','Sardinia','Calabria','Marche','Abruzzo')\n      regionLabel = 'Region'\n      postalFormat = { '{0:D5}' -f ((Get-Random -Maximum 99000) + 1000) }\n      phoneFormat = { '+39 0{0:D1} {1:D4} {2:D4}' -f ((Get-Random -Maximum 9)+1), ((Get-Random -Maximum 9000)+1000), ((Get-Random -Maximum 9000)+1000) }\n      mobileFormat = { $prefix = @('320','321','322','323','324','325','326','327','328','329','330','331','333','334','335','336','337','338','339','340','341','342','343','344','345','346','347','348','349','350','351','360','361','362','363','364','365','366','368','370','371','373','377','388','389','390','391','392','393')[(Get-Random -Maximum 49)]; '+39 {0} {1:D3} {2:D4}' -f $prefix, ((Get-Random -Maximum 900)+100), ((Get-Random -Maximum 9000)+1000) }\n      addressFormat = { param($num,$street,$city,$region,$postal) \"$street, $num`n$postal $city\" }\n      companies = @('Soluzioni Italiane SRL','Roma Tech','Milano Industries','Firenze Digital','Italia Group','Venezia Partners','Napoli Corp','Torino Innovations','Sicilia Consulting','Lombarda Systems')\n    }\n  }\n  \n  # Get country-specific data or default to US\n  $cd = $countryData[$country] ?? $countryData['us']\n  \n  # Common data\n  $domains = @('gmail.com','yahoo.com','hotmail.com','outlook.com','icloud.com','mail.com','proton.me')\n  $jobTitles = @('Software Engineer','Product Manager','Data Analyst','Marketing Director','Sales Representative','HR Manager','Financial Analyst','Operations Manager','Project Coordinator','UX Designer')\n  \n  Write-XYProgress 0.3 \"Generating $($cd.countryName) data...\"\n  \n  $results = [System.Collections.Generic.List[object]]::new()\n  $rows = [System.Collections.Generic.List[object]]::new()\n  \n  for ($i = 0; $i -lt $count; $i++) {\n    Write-XYProgress (0.3 + 0.6 * ($i / $count)) \"Generating record $($i + 1) of $count...\"\n    \n    $firstName = $cd.firstNames[(Get-Random -Maximum $cd.firstNames.Count)]\n    $lastName = $cd.lastNames[(Get-Random -Maximum $cd.lastNames.Count)]\n    $fullName = \"$firstName $lastName\"\n    $email = \"$($firstName.ToLower()).$($lastName.ToLower().Replace(' ',''))@$($domains[(Get-Random -Maximum $domains.Count)])\"\n    $phone = & $cd.phoneFormat\n    $streetNum = (Get-Random -Maximum 299) + 1\n    $street = $cd.streets[(Get-Random -Maximum $cd.streets.Count)]\n    $city = $cd.cities[(Get-Random -Maximum $cd.cities.Count)]\n    $region = $cd.regions[(Get-Random -Maximum $cd.regions.Count)]\n    $postal = & $cd.postalFormat\n    $address = & $cd.addressFormat $streetNum $street $city $region $postal\n    $company = $cd.companies[(Get-Random -Maximum $cd.companies.Count)]\n    $jobTitle = $jobTitles[(Get-Random -Maximum $jobTitles.Count)]\n    [int]$birthYear = 1958 + (Get-Random -Maximum 51)\n    [int]$birthMonth = 1 + (Get-Random -Maximum 12)\n    [int]$birthDay = 1 + (Get-Random -Maximum 28)\n    $dob = '{0:D4}-{1:D2}-{2:D2}' -f $birthYear, $birthMonth, $birthDay\n    \n    # Generate additional data for identity type\n    $mobile = & $cd.mobileFormat\n    $workPhone = & $cd.phoneFormat\n    $personalEmail = \"$($firstName.ToLower()).$($lastName.ToLower().Replace(' ',''))@$($domains[(Get-Random -Maximum $domains.Count)])\"\n    $companyDomain = ($company.ToLower() -replace '[^a-z0-9]','') + '.com'\n    $workEmail = \"$($firstName.ToLower()).$($lastName.ToLower().Replace(' ',''))@$companyDomain\"\n    $workStreetNum = (Get-Random -Maximum 299) + 1\n    $workStreet = $cd.streets[(Get-Random -Maximum $cd.streets.Count)]\n    $workCity = $cd.cities[(Get-Random -Maximum $cd.cities.Count)]\n    $workRegion = $cd.regions[(Get-Random -Maximum $cd.regions.Count)]\n    $workPostal = & $cd.postalFormat\n    $workAddress = & $cd.addressFormat $workStreetNum $workStreet $workCity $workRegion $workPostal\n    \n    $record = switch ($dataType) {\n      'person' { [pscustomobject]@{ name=$fullName; email=$email; phone=$phone; address=$address; dob=$dob; country=$cd.countryCode } }\n      'contact' { [pscustomobject]@{ firstName=$firstName; lastName=$lastName; email=$email; phone=$phone; country=$cd.countryCode } }\n      'address' { [pscustomobject]@{ street=\"$street $streetNum\"; city=$city; region=$region; postalCode=$postal; country=$cd.countryName; countryCode=$cd.countryCode } }\n      'company' { [pscustomobject]@{ company=$company; contact=$fullName; email=$email; phone=$phone; country=$cd.countryCode } }\n      'employee' { [pscustomobject]@{ name=$fullName; email=$email; jobTitle=$jobTitle; company=$company; phone=$phone; country=$cd.countryCode } }\n      'identity' { \n        [pscustomobject]@{ \n          firstName = $firstName\n          lastName = $lastName\n          fullName = $fullName\n          dateOfBirth = $dob\n          personalEmail = $personalEmail\n          mobile = $mobile\n          phone = $phone\n          address = $address\n          street = \"$street $streetNum\"\n          city = $city\n          region = $region\n          postalCode = $postal\n          country = $cd.countryName\n          countryCode = $cd.countryCode\n          company = $company\n          jobTitle = $jobTitle\n          workEmail = $workEmail\n          workPhone = $workPhone\n          workAddress = $workAddress\n          workStreet = \"$workStreet $workStreetNum\"\n          workCity = $workCity\n          workRegion = $workRegion\n          workPostalCode = $workPostal\n        } \n      }\n    }\n    $results.Add($record)\n    \n    if ($count -le 10) {\n      $rowData = switch ($dataType) {\n        'person' { @(($i+1), $fullName, $email, $phone) }\n        'contact' { @(($i+1), $firstName, $lastName, $email) }\n        'address' { @(($i+1), \"$street $streetNum\", $city, $postal) }\n        'company' { @(($i+1), $company, $fullName, $email) }\n        'employee' { @(($i+1), $fullName, $jobTitle, $company) }\n        'identity' { @(($i+1), $fullName, $personalEmail, $company) }\n      }\n      $rows.Add($rowData)\n    }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  $headers = switch ($dataType) {\n    'person' { @('#','Name','Email','Phone') }\n    'contact' { @('#','First Name','Last Name','Email') }\n    'address' { @('#','Street','City','Postal Code') }\n    'company' { @('#','Company','Contact','Email') }\n    'employee' { @('#','Name','Job Title','Company') }\n    'identity' { @('#','Name','Personal Email','Company') }\n  }\n  $typeNames = @{ person='Person'; contact='Contact'; address='Address'; company='Company'; employee='Employee'; identity='Full Identity' }\n  \n  if ($count -le 10) {\n    Write-XY @{ table = @{ title=\"Fake $($typeNames[$dataType]) Data ($($cd.countryName))\"; header=$headers; rows=$rows.ToArray(); caption=\"Generated $count record(s)\" } }\n  } else {\n    Write-XY @{ table = @{ title=\"Fake $($typeNames[$dataType]) Data ($($cd.countryName))\"; header=@('Property','Value'); rows=@(@('Type', $typeNames[$dataType]), @('Country', $cd.countryName), @('Count', $count), @('Sample', $results[0].name ?? $results[0].company ?? $results[0].street)); caption=\"Generated $count records (data in output)\" } }\n  }\n  [pscustomobject]@{ tool='Fake Data Generator'; type=$dataType; country=$cd.countryCode; countryName=$cd.countryName; count=$count; data=$results.ToArray() }\n}\n\n# ------------------------- Syntax Validator\nfunction Invoke-SyntaxValidator {\n  param($Params, $JobInput, [string]$Cwd)\n  Write-XYProgress 0.05 'Validating parameters...'\n  \n  $format = Get-Param $Params 'syntaxFormat' 'json'\n  $source = Get-Param $Params 'syntaxSource' 'field'\n  $saveFormatted = if ($Params.PSObject.Properties.Name -contains 'syntaxSaveFormatted') { [bool]$Params.syntaxSaveFormatted } else { $false }\n  $content = ''\n  $fileName = ''\n  \n  # Get input content\n  switch ($source) {\n    'field' { $content = Get-Param $Params 'syntaxInput' '' }\n    'file' {\n      $filePath = Get-Param $Params 'syntaxFilePath' ''\n      if (-not $filePath) { throw 'File path is required when source is file' }\n      $fullPath = if ([System.IO.Path]::IsPathRooted($filePath)) { $filePath } else { Join-Path $Cwd $filePath }\n      if (-not (Test-Path $fullPath)) { throw \"File not found: $fullPath\" }\n      $content = [System.IO.File]::ReadAllText($fullPath, [System.Text.Encoding]::UTF8)\n      $fileName = [System.IO.Path]::GetFileName($fullPath)\n    }\n    'input' {\n      $inputData = $JobInput.data\n      if (-not $inputData) { throw 'No input data available from previous job' }\n      $path = Get-Param $Params 'syntaxDataPath' ''\n      $val = Get-NestedValue $inputData $path\n      if ($null -eq $val) { throw \"Data path '$path' not found in input data\" }\n      $content = if ($val -is [string]) { $val } else { ($val | ConvertTo-Json -Compress -Depth 20) }\n    }\n  }\n  \n  if (-not $content.Trim()) { throw 'No content provided for validation' }\n  \n  Write-XYProgress 0.2 \"Validating $($format.ToUpper())...\"\n  \n  $valid = $true\n  $errors = [System.Collections.Generic.List[string]]::new()\n  $warnings = [System.Collections.Generic.List[string]]::new()\n  $formatted = ''\n  $stats = @{}\n  \n  switch ($format) {\n    # -------------------- JSON --------------------\n    'json' {\n      try {\n        $parsed = $content | ConvertFrom-Json -ErrorAction Stop\n        $formatted = $parsed | ConvertTo-Json -Depth 50\n        $stats['type'] = if ($content.Trim().StartsWith('[')) { 'Array' } else { 'Object' }\n        $stats['depth'] = 0\n        # Calculate depth\n        $depthCount = 0; $maxDepth = 0\n        foreach ($c in $content.ToCharArray()) {\n          if ($c -eq '{' -or $c -eq '[') { $depthCount++; if ($depthCount -gt $maxDepth) { $maxDepth = $depthCount } }\n          elseif ($c -eq '}' -or $c -eq ']') { $depthCount-- }\n        }\n        $stats['depth'] = $maxDepth\n        $stats['keys'] = if ($parsed -is [array]) { $parsed.Count } else { ($parsed.PSObject.Properties | Measure-Object).Count }\n      } catch {\n        $valid = $false\n        $errors.Add(\"JSON Parse Error: $($_.Exception.Message)\")\n      }\n    }\n    \n    # -------------------- XML --------------------\n    'xml' {\n      try {\n        $xmlDoc = [xml]$content\n        # Pretty print XML\n        $sw = [System.IO.StringWriter]::new()\n        $xws = [System.Xml.XmlWriterSettings]::new()\n        $xws.Indent = $true\n        $xws.IndentChars = '  '\n        $xws.OmitXmlDeclaration = $false\n        $xw = [System.Xml.XmlWriter]::Create($sw, $xws)\n        $xmlDoc.WriteTo($xw)\n        $xw.Flush()\n        $formatted = $sw.ToString()\n        $stats['rootElement'] = $xmlDoc.DocumentElement.Name\n        $stats['elements'] = ($xmlDoc.SelectNodes('//*') | Measure-Object).Count\n        $stats['attributes'] = ($xmlDoc.SelectNodes('//@*') | Measure-Object).Count\n        # Lint checks\n        if (-not $content.Trim().StartsWith('<?xml')) { $warnings.Add('Missing XML declaration (<?xml version=\"1.0\"?>)') }\n        if ($xmlDoc.DocumentElement.NamespaceURI -and -not $xmlDoc.DocumentElement.Prefix) { $warnings.Add('Default namespace used without prefix - may cause XPath issues') }\n      } catch {\n        $valid = $false\n        $errors.Add(\"XML Parse Error: $($_.Exception.Message)\")\n      }\n    }\n    \n    # -------------------- YAML --------------------\n    'yaml' {\n      # Basic YAML validation (PowerShell doesn't have built-in YAML)\n      $lines = $content -split \"`n\"\n      $indentStack = [System.Collections.Generic.Stack[int]]::new()\n      $indentStack.Push(0)\n      $lineNum = 0\n      $keyCount = 0\n      $listItems = 0\n      \n      foreach ($line in $lines) {\n        $lineNum++\n        $trimmed = $line.TrimEnd()\n        if (-not $trimmed -or $trimmed.StartsWith('#')) { continue }\n        \n        # Check for tabs\n        if ($trimmed -match '^\\t') { $errors.Add(\"Line ${lineNum}: Tabs are not allowed in YAML, use spaces\"); $valid = $false }\n        \n        # Calculate indent\n        $indent = 0\n        foreach ($c in $line.ToCharArray()) { if ($c -eq ' ') { $indent++ } else { break } }\n        \n        # Validate indent consistency\n        if ($indent % 2 -ne 0 -and $indent -gt 0) { $warnings.Add(\"Line ${lineNum}: Inconsistent indentation ($indent spaces), recommend 2-space increments\") }\n        \n        # Check for key-value pairs\n        if ($trimmed -match '^[\\w][\\w\\s-]*:') { $keyCount++ }\n        if ($trimmed.StartsWith('- ')) { $listItems++ }\n        \n        # Check for common errors\n        if ($trimmed -match ':\\s*\\|\\s*$' -or $trimmed -match ':\\s*>\\s*$') { } # Multiline OK\n        elseif ($trimmed -match ':.*:' -and -not ($trimmed -match '\".*:.*\"' -or $trimmed -match \"'.*:.*'\")) {\n          $warnings.Add(\"Line ${lineNum}: Multiple colons - ensure values with colons are quoted\")\n        }\n        \n        # Check unquoted special values\n        if ($trimmed -match ':\\s*(yes|no|on|off|true|false)\\s*$' -and -not ($trimmed -match '\"' -or $trimmed -match \"'\")) {\n          $warnings.Add(\"Line ${lineNum}: Boolean-like value should be quoted to avoid ambiguity\")\n        }\n      }\n      \n      if ($keyCount -eq 0 -and $listItems -eq 0) { $errors.Add('No valid YAML structure detected'); $valid = $false }\n      \n      $stats['keys'] = $keyCount\n      $stats['listItems'] = $listItems\n      $stats['lines'] = $lineNum\n      \n      # Format output (basic indentation cleanup)\n      $formatted = ($lines | ForEach-Object { $_.TrimEnd() }) -join \"`n\"\n    }\n    \n    # -------------------- Markdown --------------------\n    'markdown' {\n      $lines = $content -split \"`n\"\n      $lineNum = 0\n      $headings = [System.Collections.Generic.List[object]]::new()\n      $links = 0; $images = 0; $codeBlocks = 0; $inCodeBlock = $false\n      $lastHeadingLevel = 0\n      \n      foreach ($line in $lines) {\n        $lineNum++\n        $trimmed = $line.TrimEnd()\n        \n        # Code blocks\n        if ($trimmed -match '^```') {\n          $inCodeBlock = -not $inCodeBlock\n          $codeBlocks++\n          continue\n        }\n        if ($inCodeBlock) { continue }\n        \n        # Headings\n        if ($trimmed -match '^(#{1,6})\\s+(.+)$') {\n          $level = $Matches[1].Length\n          $text = $Matches[2]\n          $headings.Add([pscustomobject]@{ level=$level; text=$text; line=$lineNum })\n          \n          # Lint: heading hierarchy\n          if ($level -gt $lastHeadingLevel + 1 -and $lastHeadingLevel -gt 0) {\n            $warnings.Add(\"Line ${lineNum}: Heading level skipped (H$lastHeadingLevel to H$level)\")\n          }\n          $lastHeadingLevel = $level\n          \n          # Lint: no space after #\n          if ($line -match '^#+[^\\s#]') { $warnings.Add(\"Line ${lineNum}: Missing space after heading marker\") }\n        }\n        \n        # Links\n        $linkMatches = [regex]::Matches($trimmed, '\\[([^\\]]+)\\]\\(([^)]+)\\)')\n        $links += $linkMatches.Count\n        foreach ($m in $linkMatches) {\n          $url = $m.Groups[2].Value\n          if ($url -notmatch '^(https?://|mailto:|#|/)' -and $url -notmatch '\\.\\w+$') {\n            $warnings.Add(\"Line ${lineNum}: Potentially invalid link: $url\")\n          }\n        }\n        \n        # Images\n        $images += ([regex]::Matches($trimmed, '!\\[([^\\]]*)\\]\\(([^)]+)\\)')).Count\n        \n        # Lint: trailing whitespace\n        if ($line -match '\\s{3,}$') { $warnings.Add(\"Line ${lineNum}: Excessive trailing whitespace\") }\n        \n        # Lint: hard tabs\n        if ($line -match '\\t' -and -not $inCodeBlock) { $warnings.Add(\"Line ${lineNum}: Tab character found, prefer spaces\") }\n        \n        # Lint: multiple blank lines\n        if ($lineNum -gt 1 -and -not $trimmed -and -not $lines[$lineNum - 2].Trim()) {\n          # Skip duplicate warnings\n        }\n      }\n      \n      if ($inCodeBlock) { $errors.Add('Unclosed code block (missing closing ```)'); $valid = $false }\n      if ($headings.Count -eq 0) { $warnings.Add('No headings found in document') }\n      if ($headings.Count -gt 0 -and $headings[0].level -ne 1) { $warnings.Add('Document should start with H1 heading') }\n      \n      $stats['headings'] = $headings.Count\n      $stats['links'] = $links\n      $stats['images'] = $images\n      $stats['codeBlocks'] = [Math]::Floor($codeBlocks / 2)\n      $stats['lines'] = $lineNum\n      \n      $formatted = $content\n    }\n    \n    # -------------------- CSV --------------------\n    'csv' {\n      $lines = @($content -split \"`n\" | Where-Object { $_.Trim() })\n      if ($lines.Count -eq 0) { $errors.Add('Empty CSV content'); $valid = $false }\n      else {\n        # Detect delimiter\n        $firstLine = $lines[0]\n        $delimiterCandidates = @(',', ';', \"`t\", '|')\n        $delimiterCounts = @{}\n        foreach ($d in $delimiterCandidates) { $delimiterCounts[$d] = @($firstLine.ToCharArray() | Where-Object { $_ -eq $d }).Count }\n        $delimiter = ($delimiterCounts.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First 1).Key\n        if ($delimiterCounts[$delimiter] -eq 0) { $delimiter = ',' }\n        \n        # Parse and validate\n        $headerCols = ($firstLine -split [regex]::Escape($delimiter)).Count\n        $rowNum = 0\n        $maxCols = $headerCols\n        $minCols = $headerCols\n        \n        foreach ($line in $lines) {\n          $rowNum++\n          $cols = ($line -split [regex]::Escape($delimiter)).Count\n          if ($cols -ne $headerCols) {\n            $errors.Add(\"Row ${rowNum}: Column count mismatch (expected $headerCols, got $cols)\")\n            $valid = $false\n          }\n          if ($cols -gt $maxCols) { $maxCols = $cols }\n          if ($cols -lt $minCols) { $minCols = $cols }\n          \n          # Check for unescaped quotes\n          $quoteCount = @($line.ToCharArray() | Where-Object { $_ -eq '\"' }).Count\n          if ($quoteCount % 2 -ne 0) { $warnings.Add(\"Row ${rowNum}: Unbalanced quotes\") }\n        }\n        \n        $stats['rows'] = $rowNum\n        $stats['columns'] = $headerCols\n        $stats['delimiter'] = switch ($delimiter) { ',' { 'Comma' }; ';' { 'Semicolon' }; \"`t\" { 'Tab' }; '|' { 'Pipe' }; default { $delimiter } }\n        \n        # Format CSV (align columns for display)\n        try {\n          $csvData = $content | ConvertFrom-Csv -Delimiter $delimiter -ErrorAction Stop\n          $formatted = ($csvData | ConvertTo-Csv -Delimiter $delimiter -NoTypeInformation) -join \"`n\"\n        } catch {\n          $formatted = $content\n          $warnings.Add(\"Could not parse CSV for formatting: $($_.Exception.Message)\")\n        }\n      }\n    }\n    \n    # -------------------- TOML --------------------\n    'toml' {\n      $lines = $content -split \"`n\"\n      $lineNum = 0\n      $sections = [System.Collections.Generic.List[string]]::new()\n      $keyCount = 0\n      $currentSection = 'root'\n      \n      foreach ($line in $lines) {\n        $lineNum++\n        $trimmed = $line.Trim()\n        if (-not $trimmed -or $trimmed.StartsWith('#')) { continue }\n        \n        # Section headers\n        if ($trimmed -match '^\\[\\[?([^\\]]+)\\]\\]?$') {\n          $currentSection = $Matches[1]\n          $sections.Add($currentSection)\n          continue\n        }\n        \n        # Key-value pairs\n        if ($trimmed -match '^([\\w.-]+)\\s*=\\s*(.+)$') {\n          $key = $Matches[1]\n          $value = $Matches[2]\n          $keyCount++\n          \n          # Validate value types\n          if ($value -match '^\".*[^\\\\]\"$' -or $value -match \"^'.*'$\") { } # String OK\n          elseif ($value -match '^-?\\d+$') { } # Integer OK\n          elseif ($value -match '^-?\\d+\\.\\d+$') { } # Float OK\n          elseif ($value -match '^(true|false)$') { } # Boolean OK\n          elseif ($value -match '^\\d{4}-\\d{2}-\\d{2}') { } # Date OK\n          elseif ($value -match '^\\[') { } # Array OK\n          elseif ($value -match '^\\{') { } # Inline table OK\n          else { $warnings.Add(\"Line ${lineNum}: Unquoted string value for key '$key'\") }\n        }\n        elseif (-not $trimmed.StartsWith('[')) {\n          $errors.Add(\"Line ${lineNum}: Invalid TOML syntax\")\n          $valid = $false\n        }\n      }\n      \n      $stats['sections'] = $sections.Count\n      $stats['keys'] = $keyCount\n      $stats['lines'] = $lineNum\n      $formatted = $content\n    }\n    \n    # -------------------- HTML --------------------\n    'html' {\n      # Basic HTML validation\n      $tagStack = [System.Collections.Generic.Stack[string]]::new()\n      $selfClosing = @('area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr')\n      \n      # Find all tags\n      $tagMatches = [regex]::Matches($content, '<(/?)([\\w-]+)([^>]*?)(/?)>')\n      $tagCount = 0\n      \n      foreach ($m in $tagMatches) {\n        $isClose = $m.Groups[1].Value -eq '/'\n        $tagName = $m.Groups[2].Value.ToLower()\n        $isSelfClose = $m.Groups[4].Value -eq '/' -or $selfClosing -contains $tagName\n        $tagCount++\n        \n        if ($isClose) {\n          if ($tagStack.Count -eq 0) {\n            $errors.Add(\"Unexpected closing tag: </$tagName>\")\n            $valid = $false\n          }\n          elseif ($tagStack.Peek() -ne $tagName) {\n            $errors.Add(\"Mismatched tag: expected </$($tagStack.Peek())>, found </$tagName>\")\n            $valid = $false\n            $tagStack.Pop() | Out-Null\n          }\n          else {\n            $tagStack.Pop() | Out-Null\n          }\n        }\n        elseif (-not $isSelfClose) {\n          $tagStack.Push($tagName)\n        }\n      }\n      \n      while ($tagStack.Count -gt 0) {\n        $unclosed = $tagStack.Pop()\n        $errors.Add(\"Unclosed tag: <$unclosed>\")\n        $valid = $false\n      }\n      \n      # Lint checks\n      if ($content -notmatch '<!DOCTYPE\\s+html' -and $content -match '<html') {\n        $warnings.Add('Missing DOCTYPE declaration')\n      }\n      if ($content -match '<html' -and $content -notmatch '<html[^>]*lang=') {\n        $warnings.Add('Missing lang attribute on <html> tag')\n      }\n      if ($content -match '<img' -and $content -notmatch '<img[^>]*alt=') {\n        $warnings.Add('Image tag(s) missing alt attribute')\n      }\n      if ($content -match '<head' -and $content -notmatch '<meta[^>]*charset') {\n        $warnings.Add('Missing charset meta tag')\n      }\n      \n      $stats['tags'] = $tagCount\n      $stats['hasDoctype'] = $content -match '<!DOCTYPE'\n      $stats['hasHead'] = $content -match '<head'\n      $stats['hasBody'] = $content -match '<body'\n      \n      # Basic formatting (indent)\n      $formatted = $content -replace '>\\s*<', \">\\n<\"\n    }\n    \n    # -------------------- INI --------------------\n    'ini' {\n      $lines = $content -split \"`n\"\n      $lineNum = 0\n      $sections = [System.Collections.Generic.List[string]]::new()\n      $keyCount = 0\n      $currentSection = 'global'\n      \n      foreach ($line in $lines) {\n        $lineNum++\n        $trimmed = $line.Trim()\n        if (-not $trimmed -or $trimmed.StartsWith(';') -or $trimmed.StartsWith('#')) { continue }\n        \n        # Section\n        if ($trimmed -match '^\\[([^\\]]+)\\]$') {\n          $currentSection = $Matches[1]\n          $sections.Add($currentSection)\n          continue\n        }\n        \n        # Key=Value\n        if ($trimmed -match '^([^=]+)=(.*)$') {\n          $keyCount++\n        }\n        else {\n          $errors.Add(\"Line ${lineNum}: Invalid INI syntax\")\n          $valid = $false\n        }\n      }\n      \n      $stats['sections'] = $sections.Count\n      $stats['keys'] = $keyCount\n      $stats['lines'] = $lineNum\n      $formatted = $content\n    }\n    \n    # -------------------- Properties --------------------\n    'properties' {\n      $lines = $content -split \"`n\"\n      $lineNum = 0\n      $keyCount = 0\n      $continuations = 0\n      \n      foreach ($line in $lines) {\n        $lineNum++\n        $trimmed = $line.TrimStart()\n        if (-not $trimmed -or $trimmed.StartsWith('#') -or $trimmed.StartsWith('!')) { continue }\n        \n        # Check for continuation\n        if ($line.EndsWith('\\')) { $continuations++; continue }\n        \n        # Key=Value or Key:Value or Key Value\n        if ($trimmed -match '^([^=:\\s]+)\\s*[=:]\\s*(.*)$' -or $trimmed -match '^([^\\s]+)\\s+(.+)$') {\n          $keyCount++\n          $key = $Matches[1]\n          \n          # Lint: check for special characters in key\n          if ($key -match '[^\\w.-]') { $warnings.Add(\"Line ${lineNum}: Key '$key' contains special characters\") }\n        }\n        elseif ($trimmed) {\n          $warnings.Add(\"Line ${lineNum}: Ambiguous syntax - could not parse key-value pair\")\n        }\n      }\n      \n      $stats['keys'] = $keyCount\n      $stats['continuations'] = $continuations\n      $stats['lines'] = $lineNum\n      $formatted = $content\n    }\n  }\n  \n  Write-XYProgress 0.8 'Generating output...'\n  \n  # Build summary rows\n  $summaryRows = @(\n    @('Format', $format.ToUpper()),\n    @('Valid', $(if ($valid) { 'Yes' } else { 'No' })),\n    @('Errors', $errors.Count),\n    @('Warnings', $warnings.Count),\n    @('Size', \"$($content.Length) chars\")\n  )\n  $statsKeyNames = @{\n    'type'='Type'; 'depth'='Nesting Depth'; 'keys'='Keys/Properties'\n    'rootElement'='Root Element'; 'elements'='Elements'; 'attributes'='Attributes'\n    'listItems'='List Items'; 'lines'='Lines'; 'headings'='Headings'\n    'links'='Links'; 'images'='Images'; 'codeBlocks'='Code Blocks'\n    'rows'='Rows'; 'columns'='Columns'; 'delimiter'='Delimiter'\n    'sections'='Sections'; 'tags'='HTML Tags'; 'continuations'='Line Continuations'\n    'hasDoctype'='Has DOCTYPE'; 'hasHead'='Has <head>'; 'hasBody'='Has <body>'\n  }\n  $statsEntries = @($stats.GetEnumerator())\n  foreach ($entry in $statsEntries) {\n    $statKey = $entry.Key\n    $statVal = $entry.Value\n    $displayKey = if ($statsKeyNames.ContainsKey($statKey)) { $statsKeyNames[$statKey] } else { [string]$statKey }\n    $displayVal = if ($statVal -is [bool]) { if ($statVal) { 'Yes' } else { 'No' } } else { $statVal }\n    $summaryRows += ,@($displayKey, $displayVal)\n  }\n  \n  Write-XY @{ table = @{ title=\"$($format.ToUpper()) Validation Results\"; header=@('Property','Value'); rows=$summaryRows; caption=$(if ($valid) { 'Validation passed' } else { 'Validation failed' }) } }\n  \n  if ($errors.Count -gt 0) {\n    $errorRows = for ($i = 0; $i -lt [Math]::Min($errors.Count, 20); $i++) { ,@(($i + 1), $errors[$i]) }\n    Write-XY @{ table = @{ title='Errors'; header=@('#','Error'); rows=$errorRows; caption=$(if ($errors.Count -gt 20) { \"Showing 20 of $($errors.Count) errors\" } else { '' }) } }\n  }\n  \n  if ($warnings.Count -gt 0) {\n    $warnRows = for ($i = 0; $i -lt [Math]::Min($warnings.Count, 20); $i++) { ,@(($i + 1), $warnings[$i]) }\n    Write-XY @{ table = @{ title='Warnings (Lint)'; header=@('#','Warning'); rows=$warnRows; caption=$(if ($warnings.Count -gt 20) { \"Showing 20 of $($warnings.Count) warnings\" } else { '' }) } }\n  }\n  \n  # Show formatted preview\n  if ($valid -and $formatted) {\n    $preview = if ($formatted.Length -gt 2000) { $formatted.Substring(0, 2000) + \"`n... (truncated)\" } else { $formatted }\n    Write-XY @{ text = @{ title='Formatted Output'; content=$preview; caption='' } }\n  }\n  \n  # Save formatted file\n  $outputFiles = @()\n  if ($saveFormatted -and $valid -and $formatted) {\n    $ext = switch ($format) {\n      'json' { 'json' }; 'xml' { 'xml' }; 'yaml' { 'yaml' }; 'markdown' { 'md' }\n      'csv' { 'csv' }; 'toml' { 'toml' }; 'html' { 'html' }; 'ini' { 'ini' }\n      'properties' { 'properties' }; default { 'txt' }\n    }\n    $outName = if ($fileName) { [System.IO.Path]::GetFileNameWithoutExtension($fileName) + \".formatted.$ext\" } else { \"formatted.$ext\" }\n    $outPath = Join-Path $Cwd $outName\n    [System.IO.File]::WriteAllText($outPath, $formatted, [System.Text.Encoding]::UTF8)\n    $outputFiles += $outName\n    Write-XY @{ files = $outputFiles }\n  }\n  \n  Write-XYProgress 0.95 'Finalizing...'\n  \n  [pscustomobject]@{\n    tool = 'Syntax Validator'\n    format = $format\n    valid = $valid\n    errors = $errors.ToArray()\n    warnings = $warnings.ToArray()\n    errorCount = $errors.Count\n    warningCount = $warnings.Count\n    stats = $stats\n    inputSize = $content.Length\n    formattedOutput = $(if ($saveFormatted -and $valid) { $formatted } else { $null })\n    outputFiles = $outputFiles\n  }\n}\n\n# ------------------------- Main -------------------------\ntry {\n  $job = Read-JobFromStdin\n  $params = $job.params\n  $tool = if ($params.PSObject.Properties.Name -contains 'tool') { $params.tool } else { 'tokenGenerator' }\n  $cwd = if ($job.PSObject.Properties.Name -contains 'cwd') { [string]$job.cwd } else { (Get-Location).Path }\n  $jobInput = if ($job.PSObject.Properties.Name -contains 'input') { $job.input } else { @{} }\n\n  $result = $null\n  switch ($tool) {\n    'tokenGenerator' { $result = Invoke-TokenGenerator -Params $params }\n    'uuidGenerator'  { $result = Invoke-UUIDGenerator -Params $params }\n    'hashText'       { $result = Invoke-HashText -Params $params -JobInput $jobInput }\n    'qrCode'         { $result = Invoke-QRCode -Params $params -JobInput $jobInput -Cwd $cwd }\n    'ibanValidator'  { $result = Invoke-IBANValidator -Params $params -JobInput $jobInput }\n    'passphrase'     { $result = Invoke-PassphraseGenerator -Params $params }\n    'loremIpsum'     { $result = Invoke-LoremIpsum -Params $params -Cwd $cwd }\n    'base64'         { $result = Invoke-Base64 -Params $params -JobInput $jobInput }\n    'urlEncode'      { $result = Invoke-UrlEncode -Params $params -JobInput $jobInput }\n    'timestamp'      { $result = Invoke-TimestampConverter -Params $params -JobInput $jobInput }\n    'jsonFormatter'  { $result = Invoke-JsonFormatter -Params $params -JobInput $jobInput }\n    'caseConverter'  { $result = Invoke-CaseConverter -Params $params -JobInput $jobInput }\n    'colorConverter' { $result = Invoke-ColorConverter -Params $params -JobInput $jobInput -Cwd $cwd }\n    'imageConverter' { $result = Invoke-ImageConverter -Params $params -JobInput $jobInput -Cwd $cwd }\n    'slugGenerator'  { $result = Invoke-SlugGenerator -Params $params -JobInput $jobInput }\n    'textStatistics' { $result = Invoke-TextStatistics -Params $params -JobInput $jobInput }\n    'creditCardValidator' { $result = Invoke-CreditCardValidator -Params $params -JobInput $jobInput }\n    'emailValidator' { $result = Invoke-EmailValidator -Params $params -JobInput $jobInput }\n    'barcodeGenerator' { $result = Invoke-BarcodeGenerator -Params $params -JobInput $jobInput -Cwd $cwd }\n    'fakeDataGenerator' { $result = Invoke-FakeDataGenerator -Params $params }\n    'syntaxValidator' { $result = Invoke-SyntaxValidator -Params $params -JobInput $jobInput -Cwd $cwd }\n    default          { throw \"Unknown tool: $tool\" }\n  }\n\n  Write-XYSuccess -Data $result -Description (\"{0} completed successfully\" -f $result.tool)\n  [Console]::Out.Flush()\n  exit 0\n}\ncatch {\n  Write-XYError -Code 1 -Description ($_.Exception.Message)\n  [Console]::Out.Flush()\n  exit 1\n}",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "tool",
						"title": "Tool",
						"type": "toolset",
						"caption": "Select a tool from the toolbox.",
						"data": {
							"tools": [
								{
									"id": "tokenGenerator",
									"title": "Token Generator",
									"description": "Generate random tokens/strings with customizable character sets and length.",
									"fields": [
										{
											"id": "tokenLength",
											"title": "Length",
											"type": "text",
											"value": 64,
											"variant": "number",
											"caption": "The length of the generated token (1-1024)."
										},
										{
											"id": "includeUppercase",
											"title": "Include Uppercase (ABC...)",
											"type": "checkbox",
											"value": true,
											"caption": "Include uppercase letters A-Z in the token."
										},
										{
											"id": "includeLowercase",
											"title": "Include Lowercase (abc...)",
											"type": "checkbox",
											"value": true,
											"caption": "Include lowercase letters a-z in the token."
										},
										{
											"id": "includeNumbers",
											"title": "Include Numbers (123...)",
											"type": "checkbox",
											"value": true,
											"caption": "Include digits 0-9 in the token."
										},
										{
											"id": "includeSymbols",
											"title": "Include Symbols",
											"type": "checkbox",
											"value": false,
											"caption": "Include special symbols !()_+-=[]{}|;:,.? in the token."
										},
										{
											"id": "tokenCount",
											"title": "Number of Tokens",
											"type": "text",
											"value": 1,
											"variant": "number",
											"caption": "How many tokens to generate (1-100)."
										}
									]
								},
								{
									"id": "uuidGenerator",
									"title": "UUID Generator",
									"description": "Generate Universally Unique Identifiers (UUIDs) in various versions.",
									"fields": [
										{
											"id": "uuidVersion",
											"title": "UUID Version",
											"type": "select",
											"value": "v1 - Time-based [v1], v4 - Random [v4], v6 - Reordered Time-based [v6], v7 - Unix Epoch Time-based [v7], Nil UUID (all zeros) [nil], Max UUID (all ones) [max]",
											"caption": "Select the UUID version to generate."
										},
										{
											"id": "uuidFormat",
											"title": "Format",
											"type": "select",
											"value": "Standard (lowercase with dashes) [standard], Uppercase [uppercase], No dashes [nodashes], URN format [urn]",
											"caption": "Select the output format for the UUID."
										},
										{
											"id": "uuidCount",
											"title": "Number of UUIDs",
											"type": "text",
											"value": 1,
											"variant": "number",
											"caption": "How many UUIDs to generate (1-100)."
										}
									]
								},
								{
									"id": "hashText",
									"title": "Hash Text",
									"description": "Hash a text string using multiple algorithms: MD5, SHA1, SHA256, SHA224, SHA512, SHA384, SHA3, RIPEMD160.",
									"fields": [
										{
											"id": "hashSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the text to hash from."
										},
										{
											"id": "hashInput",
											"title": "Text to Hash",
											"type": "textarea",
											"value": "",
											"caption": "Enter the text string you want to hash. (Used when Data Source is 'text field')"
										},
										{
											"id": "hashDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field (e.g. 'user.name'). Leave empty to use entire input data as string. (Used when Data Source is 'input data')"
										},
										{
											"id": "hashEncoding",
											"title": "Digest Encoding",
											"type": "select",
											"value": "Hexadecimal (base 16) [hex], Base64 [base64], Binary (raw) [binary]",
											"caption": "Select the output encoding for the hash digests."
										}
									]
								},
								{
									"id": "qrCode",
									"title": "QR Code Generator",
									"description": "Generate a QR code for a URL or text with customizable colors and error correction.",
									"fields": [
										{
											"id": "qrSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the text/URL to encode."
										},
										{
											"id": "qrText",
											"title": "Text / URL",
											"type": "textarea",
											"value": "",
											"caption": "Enter the text or URL to encode in the QR code."
										},
										{
											"id": "qrDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										},
										{
											"id": "qrForeground",
											"title": "Foreground Color",
											"type": "text",
											"value": "#000000",
											"variant": "color",
											"caption": "Color of the QR code modules (dark parts)."
										},
										{
											"id": "qrBackground",
											"title": "Background Color",
											"type": "text",
											"value": "#ffffff",
											"variant": "color",
											"caption": "Background color of the QR code."
										},
										{
											"id": "qrErrorLevel",
											"title": "Error Resistance",
											"type": "select",
											"value": "Low (~7% recovery) [L], Medium (~15% recovery) [M], Quartile (~25% recovery) [Q], High (~30% recovery) [H]",
											"caption": "Higher error correction allows the QR code to be read even if partially damaged."
										},
										{
											"id": "qrSize",
											"title": "Image Size",
											"type": "text",
											"value": 256,
											"variant": "number",
											"caption": "Width/height of the generated PNG image in pixels (64-1024)."
										},
										{
											"id": "qrFilename",
											"title": "Output Filename",
											"type": "text",
											"value": "qrcode.png",
											"caption": "Filename for the generated QR code image."
										}
									]
								},
								{
									"id": "ibanValidator",
									"title": "IBAN Validator",
									"description": "Validate IBAN (International Bank Account Number) and extract country, check digits, and BBAN.",
									"fields": [
										{
											"id": "ibanSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the IBAN from."
										},
										{
											"id": "ibanInput",
											"title": "IBAN",
											"type": "text",
											"value": "",
											"caption": "Enter the IBAN to validate (spaces are allowed)."
										},
										{
											"id": "ibanDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "passphrase",
									"title": "Passphrase Generator",
									"description": "Generate secure, memorable passphrases using random words.",
									"fields": [
										{
											"id": "ppWordCount",
											"title": "Number of Words",
											"type": "text",
											"value": 4,
											"variant": "number",
											"caption": "Number of words in the passphrase (3-10)."
										},
										{
											"id": "ppMaxWordLength",
											"title": "Max Word Length",
											"type": "text",
											"value": 8,
											"variant": "number",
											"caption": "Maximum length of each word in characters (3-15)."
										},
										{
											"id": "ppSeparator",
											"title": "Separator",
											"type": "select",
											"value": "Hyphen (-) [hyphen], Space ( ) [space], Dot (.) [dot], Underscore (_) [underscore], None [none]",
											"caption": "Character used to separate words."
										},
										{
											"id": "ppCapitalize",
											"title": "Capitalize Words",
											"type": "checkbox",
											"value": true,
											"caption": "Capitalize the first letter of each word."
										},
										{
											"id": "ppIncludeNumber",
											"title": "Include Number",
											"type": "checkbox",
											"value": true,
											"caption": "Add a random number (0-99) to the passphrase."
										},
										{
											"id": "ppIncludeSymbol",
											"title": "Include Symbol",
											"type": "checkbox",
											"value": false,
											"caption": "Add a random symbol (!@#$%^&*) to the passphrase."
										},
										{
											"id": "ppCount",
											"title": "Number of Passphrases",
											"type": "text",
											"value": 1,
											"variant": "number",
											"caption": "How many passphrases to generate (1-20)."
										}
									]
								},
								{
									"id": "loremIpsum",
									"title": "Lorem Ipsum Generator",
									"description": "Generate placeholder Lorem Ipsum text with customizable paragraphs, sentences, and word counts.",
									"fields": [
										{
											"id": "loremParagraphs",
											"title": "Paragraphs",
											"type": "text",
											"value": 3,
											"variant": "number",
											"caption": "Number of paragraphs to generate (1-20)."
										},
										{
											"id": "loremSentences",
											"title": "Sentences per paragraph",
											"type": "text",
											"value": 4,
											"variant": "number",
											"caption": "Number of sentences per paragraph (1-10)."
										},
										{
											"id": "loremWords",
											"title": "Words per sentence",
											"type": "text",
											"value": 10,
											"variant": "number",
											"caption": "Average number of words per sentence (3-25)."
										},
										{
											"id": "loremStartWithLorem",
											"title": "Start with lorem ipsum ?",
											"type": "checkbox",
											"value": true,
											"caption": "Begin the text with 'Lorem ipsum' for classic placeholder text."
										},
										{
											"id": "loremAsHtml",
											"title": "As html ?",
											"type": "checkbox",
											"value": false,
											"caption": "Wrap paragraphs in HTML paragraph tags."
										}
									]
								},
								{
									"id": "base64",
									"title": "Base64 Encoder/Decoder",
									"description": "Encode or decode text using Base64 encoding.",
									"fields": [
										{
											"id": "base64Mode",
											"title": "Mode",
											"type": "select",
											"value": "Encode [encode], Decode [decode]",
											"caption": "Choose to encode or decode."
										},
										{
											"id": "base64Source",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the input text."
										},
										{
											"id": "base64Input",
											"title": "Input Text",
											"type": "textarea",
											"value": "",
											"caption": "Text to encode or Base64 string to decode."
										},
										{
											"id": "base64DataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "urlEncode",
									"title": "URL Encoder/Decoder",
									"description": "Encode or decode URL components and query strings.",
									"fields": [
										{
											"id": "urlMode",
											"title": "Mode",
											"type": "select",
											"value": "Encode [encode], Decode [decode]",
											"caption": "Choose to encode or decode."
										},
										{
											"id": "urlSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the input text."
										},
										{
											"id": "urlInput",
											"title": "Input Text",
											"type": "textarea",
											"value": "",
											"caption": "Text to encode or URL-encoded string to decode."
										},
										{
											"id": "urlDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "timestamp",
									"title": "Timestamp Converter",
									"description": "Convert between Unix timestamps, ISO 8601, and human-readable date formats.",
									"fields": [
										{
											"id": "tsMode",
											"title": "Input Format",
											"type": "select",
											"value": "Current Time [now], Unix Timestamp (seconds) [unix], Unix Timestamp (milliseconds) [unixms], ISO 8601 Date [iso]",
											"caption": "Select the format of your input."
										},
										{
											"id": "tsSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the timestamp (ignored for 'Current Time')."
										},
										{
											"id": "tsInput",
											"title": "Input Value",
											"type": "text",
											"value": "",
											"caption": "The timestamp or date to convert (leave empty for 'Current Time')."
										},
										{
											"id": "tsDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "jsonFormatter",
									"title": "JSON Formatter",
									"description": "Prettify, minify, or validate JSON data.",
									"fields": [
										{
											"id": "jsonMode",
											"title": "Mode",
											"type": "select",
											"value": "Prettify [prettify], Minify [minify], Validate Only [validate]",
											"caption": "Choose the operation to perform."
										},
										{
											"id": "jsonSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the JSON."
										},
										{
											"id": "jsonInput",
											"title": "JSON Input",
											"type": "textarea",
											"value": "",
											"caption": "Paste your JSON here."
										},
										{
											"id": "jsonDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "caseConverter",
									"title": "String Case Converter",
									"description": "Convert text between different case formats.",
									"fields": [
										{
											"id": "caseType",
											"title": "Target Case",
											"type": "select",
											"value": "lowercase [lower], UPPERCASE [upper], Title Case [title], Sentence case [sentence], camelCase [camel], PascalCase [pascal], snake_case [snake], kebab-case [kebab], CONSTANT_CASE [constant]",
											"caption": "Select the target case format."
										},
										{
											"id": "caseSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the text."
										},
										{
											"id": "caseInput",
											"title": "Input Text",
											"type": "textarea",
											"value": "",
											"caption": "Text to convert."
										},
										{
											"id": "caseDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "colorConverter",
									"title": "Color Converter",
									"description": "Convert colors between HEX, RGB, and HSL formats.",
									"fields": [
										{
											"id": "colorInputFormat",
											"title": "Input Format",
											"type": "select",
											"value": "HEX (#RRGGBB) [hex], RGB (r g b) [rgb], HSL (h s% l%) [hsl]",
											"caption": "Select the format of your input color."
										},
										{
											"id": "colorSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the color value."
										},
										{
											"id": "colorInput",
											"title": "Color Value",
											"type": "text",
											"value": "",
											"caption": "Enter color (e.g., #FF5733, rgb(255,87,51), or hsl(11,100%,60%))."
										},
										{
											"id": "colorDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "imageConverter",
									"title": "Image Converter",
									"description": "Convert images between formats and resize them.",
									"fields": [
										{
											"id": "imgSource",
											"title": "File Source",
											"type": "select",
											"value": "Use path field below [field], Use job input files [files], Use job input data [input]",
											"caption": "Choose where to get the input image."
										},
										{
											"id": "imgInput",
											"title": "Input File Path",
											"type": "text",
											"value": "",
											"caption": "Path to the input image file (when File Source is 'path field')."
										},
										{
											"id": "imgFileIndex",
											"title": "File Index",
											"type": "text",
											"value": 0,
											"variant": "number",
											"caption": "Index of the file in job input files (0 = first file). Used when File Source is 'input files'."
										},
										{
											"id": "imgDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to file path in input data (e.g. 'file' or 'files[0]'). Used when File Source is 'input data'."
										},
										{
											"id": "imgOutputFormat",
											"title": "Output Format",
											"type": "select",
											"value": "PNG [png], JPEG [jpg], BMP [bmp], GIF [gif], TIFF [tiff]",
											"caption": "Select the output image format."
										},
										{
											"id": "imgResize",
											"title": "Resize Mode",
											"type": "select",
											"value": "No Resize [none], By Width (maintain aspect) [width], By Height (maintain aspect) [height], Exact Dimensions [dimensions], By Percentage [percent]",
											"caption": "How to resize the image."
										},
										{
											"id": "imgWidth",
											"title": "Width / Percentage",
											"type": "text",
											"value": 0,
											"variant": "number",
											"caption": "Target width in pixels, or percentage for 'By Percentage' mode."
										},
										{
											"id": "imgHeight",
											"title": "Height",
											"type": "text",
											"value": 0,
											"variant": "number",
											"caption": "Target height in pixels (for 'Exact Dimensions' or 'By Height' mode)."
										}
									]
								},
								{
									"id": "slugGenerator",
									"title": "Slug Generator",
									"description": "Generate URL-friendly slugs from text.",
									"fields": [
										{
											"id": "slugSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the text."
										},
										{
											"id": "slugInput",
											"title": "Input Text",
											"type": "text",
											"value": "",
											"caption": "Text to convert to a slug."
										},
										{
											"id": "slugDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										},
										{
											"id": "slugSeparator",
											"title": "Separator",
											"type": "select",
											"value": "Hyphen (-) [-], Underscore (_) [_], None []",
											"caption": "Character to separate words."
										},
										{
											"id": "slugLowercase",
											"title": "Lowercase",
											"type": "checkbox",
											"value": true,
											"caption": "Convert to lowercase."
										},
										{
											"id": "slugMaxLength",
											"title": "Max Length",
											"type": "text",
											"value": 0,
											"variant": "number",
											"caption": "Maximum length of the slug (0 for no limit)."
										}
									]
								},
								{
									"id": "textStatistics",
									"title": "Text Statistics",
									"description": "Analyze text for word count, reading time, and more.",
									"fields": [
										{
											"id": "statsSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the text."
										},
										{
											"id": "statsInput",
											"title": "Input Text",
											"type": "textarea",
											"value": "",
											"caption": "Text to analyze."
										},
										{
											"id": "statsDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "creditCardValidator",
									"title": "Credit Card Validator",
									"description": "Validate credit card numbers using Luhn algorithm and detect card type.",
									"fields": [
										{
											"id": "ccSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the card number."
										},
										{
											"id": "ccInput",
											"title": "Card Number",
											"type": "text",
											"value": "",
											"caption": "Credit card number to validate."
										},
										{
											"id": "ccDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "emailValidator",
									"title": "Email Validator",
									"description": "Validate email address format and structure.",
									"fields": [
										{
											"id": "emailSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the email."
										},
										{
											"id": "emailInput",
											"title": "Email Address",
											"type": "text",
											"value": "",
											"caption": "Email address to validate."
										},
										{
											"id": "emailDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "barcodeGenerator",
									"title": "Barcode Generator",
									"description": "Generate industry-standard barcodes as SVG files.",
									"fields": [
										{
											"id": "barcodeType",
											"title": "Barcode Type",
											"type": "select",
											"value": "Code 128 [code128], Code 39 [code39]",
											"caption": "Select the barcode format."
										},
										{
											"id": "barcodeSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Use job input data [input]",
											"caption": "Choose where to get the barcode text."
										},
										{
											"id": "barcodeText",
											"title": "Barcode Text",
											"type": "text",
											"value": "",
											"caption": "Text to encode in the barcode."
										},
										{
											"id": "barcodeDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to the data field. (Used when Data Source is 'input data')"
										}
									]
								},
								{
									"id": "fakeDataGenerator",
									"title": "Fake Data Generator",
									"description": "Generate realistic fake data for testing and development.",
									"fields": [
										{
											"id": "fakeDataType",
											"title": "Data Type",
											"type": "select",
											"value": "Full Identity [identity], Person [person], Contact [contact], Address [address], Company [company], Employee [employee]",
											"caption": "Type of fake data to generate."
										},
										{
											"id": "fakeCountry",
											"title": "Country",
											"type": "select",
											"value": "United States [us], United Kingdom [uk], Germany [de], France [fr], Netherlands [nl], Belgium [be], Spain [es], Italy [it]",
											"caption": "Country for localized names, addresses, and phone formats."
										},
										{
											"id": "fakeCount",
											"title": "Count",
											"type": "text",
											"value": 1,
											"variant": "number",
											"caption": "Number of records to generate (1-100)."
										}
									]
								},
								{
									"id": "syntaxValidator",
									"title": "Syntax Validator & Formatter",
									"description": "Validate and format JSON, XML, YAML, Markdown, CSV, TOML, HTML, INI, and Properties files.",
									"fields": [
										{
											"id": "syntaxFormat",
											"title": "Format",
											"type": "select",
											"value": "JSON [json], XML [xml], YAML [yaml], Markdown [markdown], CSV [csv], TOML [toml], HTML [html], INI [ini], Properties [properties]",
											"caption": "Select the file format to validate."
										},
										{
											"id": "syntaxSource",
											"title": "Data Source",
											"type": "select",
											"value": "Use text field below [field], Load from file [file], Use job input data [input]",
											"caption": "Choose where to get the content."
										},
										{
											"id": "syntaxInput",
											"title": "Content",
											"type": "textarea",
											"value": "",
											"caption": "Paste content to validate here."
										},
										{
											"id": "syntaxFilePath",
											"title": "File Path",
											"type": "text",
											"value": "",
											"caption": "Path to file (when source is 'file')."
										},
										{
											"id": "syntaxDataPath",
											"title": "Input Data Path",
											"type": "text",
											"value": "",
											"caption": "Dot-notation path to data field (when source is 'input')."
										},
										{
											"id": "syntaxSaveFormatted",
											"title": "Save Formatted File",
											"type": "checkbox",
											"value": false,
											"caption": "Save a pretty-printed version of the file."
										}
									]
								}
							]
						}
					}
				],
				"notes": "",
				"icon": "toolbox",
				"uid": "",
				"gid": "",
				"kill": "none",
				"runner": false
			}
		}
	]
}
